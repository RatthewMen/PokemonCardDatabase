<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pokemon Collection</title>

    <!-- update the version number as needed -->
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js"></script>
    <!-- include only the Firebase features as you need -->
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-auth-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-database-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-functions-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-messaging-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-storage-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-remote-config-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/12.6.0/firebase-performance-compat.js"></script>
    <!-- Optional local config (gitignored). Defines window.__FIREBASE_CONFIG__ -->
    <script defer src="./config/firebaseConfig.js"></script>
    <!-- ApexCharts for robust datetime charts -->
    <script defer src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

    <style media="screen">
      body { background: #F7FAFC; color: #1A202C; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      .app { display: grid; grid-template-columns: 240px 1fr; min-height: 100vh; }
      .sidebar { background: #1A202C; color: #E2E8F0; padding: 16px; display: flex; flex-direction: column; gap: 12px; }
      .brand { font-weight: 700; font-size: 18px; letter-spacing: 0.4px; margin-bottom: 8px; }
      .nav a { color: #CBD5E0; text-decoration: none; padding: 10px 12px; border-radius: 8px; display: block; }
      .nav a.active, .nav a:hover { color: #1A202C; background: #EDF2F7; }
      .content { padding: 24px; }
      .page { display: none; }
      .page.active { display: block; }
      .section-title { margin: 0 0 12px 0; font-size: 20px; }
      .muted { color: #4A5568; }
      .card { background: #FFFFFF; border: 1px solid #E2E8F0; border-radius: 10px; padding: 16px; }
      .grid { display: grid; gap: 12px; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
      .btn { background: #2B6CB0; color: #FFFFFF; border: none; border-radius: 8px; padding: 10px 12px; cursor: pointer; text-align: left; }
      .btn.secondary { background: #4A5568; }
      .btn.ghost { background: #EDF2F7; color: #1A202C; }
      .btn:disabled { opacity: 0.6; cursor: default; }
      .stack { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .chips { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
      .chip { background: #EDF2F7; border-radius: 999px; padding: 6px 10px; font-size: 12px; color: #2D3748; }
      .chip.active { background: #2B6CB0; color: #FFFFFF; }
      .divider { height: 1px; background: #E2E8F0; margin: 12px 0; }
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      .small { font-size: 12px; color: #4A5568; }
      .space-top { margin-top: 12px; }
      .space-bottom { margin-bottom: 12px; }
      .hidden { display: none !important; }
      .table { width: 100%; border-collapse: collapse; }
      .table th, .table td { padding: 8px 10px; border-bottom: 1px solid #E2E8F0; text-align: left; vertical-align: top; }
      .table th { background: #F7FAFC; font-weight: 600; }
      .db-layout { display: grid; grid-template-columns: 320px 1fr; gap: 16px; align-items: start; }
      .tree { list-style: none; padding: 0; margin: 0; }
      .tree-node { margin: 2px 0; }
      .thumb-wrap { position: relative; display: inline-block; vertical-align: middle; }
      .card-thumb { width: 36px; height: 50px; object-fit: cover; border-radius: 4px; margin-right: 8px; transition: transform .12s ease, box-shadow .12s ease; transform-origin: top left; position: relative; z-index: 1; }
      .card-thumb:hover { transform: scale(7.5); z-index: 10; box-shadow: 0 6px 18px rgba(0,0,0,.3); }
      .tree-row { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 8px; cursor: pointer; user-select: none; }
      .tree-row:hover { background: #EDF2F7; }
      .tree-label { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .tree-caret { width: 0; height: 0; border-top: 5px solid transparent; border-bottom: 5px solid transparent; border-left: 6px solid #4A5568; transition: transform .12s ease; }
      .expanded > .tree-row .tree-caret { transform: rotate(90deg); }
      .tree-children { margin-left: 14px; padding-left: 6px; border-left: 1px dashed #E2E8F0; }
      /* Modal styles */
      .modal-backdrop { position: fixed; inset: 0; background: rgba(26, 32, 44, 0.55); display: flex; align-items: center; justify-content: center; z-index: 1000; }
      .modal-panel { background: #FFFFFF; border: 1px solid #E2E8F0; border-radius: 12px; width: min(920px, 96vw); max-height: 90vh; overflow: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
      .modal-header { padding: 12px 16px; border-bottom: 1px solid #E2E8F0; display: flex; align-items: center; justify-content: space-between; }
      .modal-body { padding: 14px 16px; }
      .grid-quick { display: grid; grid-template-columns: 90px 160px 120px 1fr; gap: 8px; align-items: center; }
      .grid-quick.sealed { grid-template-columns: 90px 120px 1fr; }
      .grid-quick.cards { grid-template-columns: 90px 160px 120px 1fr; }
      .grid-quick .hdr { font-weight: 600; font-size: 12px; color: #4A5568; }
      .grid-quick input { padding: 8px; border: 1px solid #E2E8F0; border-radius: 8px; }
      .grid-quick select { padding: 8px; border: 1px solid #E2E8F0; border-radius: 8px; background: #FFFFFF; }
      .modal-footer { padding: 12px 16px; border-top: 1px solid #E2E8F0; display: flex; gap: 8px; justify-content: flex-end; }
      /* Category overview (3rd level) */
      .set-details { display: flex; gap: 12px; align-items: flex-start; }
      .set-image { width: 160px; height: 100px; object-fit: contain; border: 1px solid #E2E8F0; border-radius: 8px; background: #F7FAFC; }
      .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
      .tab-btn { padding: 6px 10px; border: 1px solid #E2E8F0; background: #EDF2F7; color: #1A202C; border-radius: 999px; cursor: pointer; }
      .tab-btn.active { background: #2B6CB0; color: #FFFFFF; border-color: #2B6CB0; }
      /* Logs page larger square buttons */
      .logs-tabs { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
      .logs-tabs .tab-btn { width: 100%; padding: 14px 12px; border-radius: 8px; font-size: 16px; text-align: center; }
      .logs-header { display: flex; justify-content: flex-end; }
      /* Small toggle slider */
      .switch { position: relative; display: inline-block; width: 44px; height: 24px; vertical-align: middle; }
      .switch input { opacity: 0; width: 0; height: 0; }
      .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #CBD5E0; transition: .2s; border-radius: 999px; }
      .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; top: 3px; background: #FFFFFF; transition: .2s; border-radius: 50%; }
      .switch input:checked + .slider { background: #2B6CB0; }
      .switch input:checked + .slider:before { transform: translateX(20px); }
      /* Set overview layout tweaks */
      .set-overview { display: flex; align-items: flex-start; justify-content: space-between; gap: 16px; }
      .kv-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 8px; }
      .kv-item { display: flex; align-items: baseline; gap: 10px; }
      .kv-label { color: #4A5568; min-width: 90px; }
      .toggle-row { display: flex; align-items: center; gap: 8px; }
      .set-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); gap: 12px; align-items: stretch; }
      /* Language view: categories laid out in two columns */
      .category-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
      @media (max-width: 900px) { .category-grid { grid-template-columns: 1fr; } }
      .set-item { list-style: disc; margin-left: 18px; padding: 4px 6px; border-radius: 6px; cursor: pointer; }
      .set-item:hover { background: #EDF2F7; }
      @media (max-width: 800px) { .app { grid-template-columns: 1fr; } .sidebar { flex-direction: row; gap: 8px; position: sticky; top: 0; z-index: 10; } }
    </style>
  </head>
  <body>
    <div class="app">
      <aside class="sidebar">
        <div class="brand">Pokemon Collection</div>
        <nav class="nav">
          <a href="#home" id="nav-home">Home</a>
          <a href="#statistics" id="nav-statistics">Statistics</a>
          <a href="#database" id="nav-database">Database</a>
          <a href="#logs" id="nav-logs">Logs</a>
          <a href="#signin" id="nav-signin">Sign In</a>
        </nav>
        <div class="divider"></div>
        <div class="small mono" id="sdkStatus">Loading Firebase…</div>
        <div class="divider"></div>
        <div class="stack">
          <button class="btn secondary hidden" id="signOut">Sign Out</button>
        </div>
        <div class="small mono" id="authStatus">Signed out</div>
      </aside>
      <main class="content">
        <section id="page-home" class="page active">
          <h2 class="section-title">Home</h2>
          <div class="card">
            <p class="muted">This homepage is blank for now. Use the sidebar to navigate.</p>
          </div>
        </section>

        <section id="page-statistics" class="page">
          <h2 class="section-title">Statistics</h2>
          <div class="card" id="statsCostCard">
            <div class="row" style="justify-content:space-between;align-items:center;">
              <div class="small muted">Total Collection Cost Over Time</div>
              <div class="tabs small" id="statsRangeTabs">
                <button class="tab-btn" data-range="1H">1H</button>
                <button class="tab-btn" data-range="1D">1D</button>
                <button class="tab-btn" data-range="7D">7D</button>
                <button class="tab-btn active" data-range="1M">1M</button>
                <button class="tab-btn" data-range="6M">6M</button>
                <button class="tab-btn" data-range="1Y">1Y</button>
                <button class="tab-btn" data-range="ALL">All</button>
              </div>
            </div>
            <div id="statsCostChart" style="height:320px; width: 100%; overflow: hidden;"></div>
            <div class="small muted" id="statsCostInfo" style="margin-top:6px;">Loading…</div>
          </div>
        </section>

        <section id="page-signin" class="page">
          <h2 class="section-title">Sign In</h2>
          <div class="card">
            <label class="small" style="display:flex;flex-direction:column;gap:6px;">
              <span>Username</span>
              <input id="signinUsername" placeholder="yourname" style="padding:8px;border:1px solid #E2E8F0;border-radius:8px;">
            </label>
            <label class="small space-top" style="display:flex;flex-direction:column;gap:6px;">
              <span>Password</span>
              <input id="signinPassword" type="password" placeholder="••••••••" style="padding:8px;border:1px solid #E2E8F0;border-radius:8px;">
            </label>
            <div class="stack space-top">
              <button class="btn" id="signinSubmit">Sign In</button>
              <button class="btn ghost" id="signupSubmit">Create Account</button>
            </div>
            <div class="small space-top muted">Use the same username/password for either action.</div>
          </div>
        </section>

        <section id="page-database" class="page">
          <h2 class="section-title">Database</h2>
          <div class="db-layout">
            <div class="card" id="dbTreeCard" style="padding:0;">
              <div class="row" style="padding:10px 12px; justify-content: space-between;">
                <button class="btn ghost small" id="dbRefreshTree" style="padding:6px 8px;">Refresh</button>
              </div>
              <div id="dbTree" style="padding: 4px 6px;"></div>
            </div>
            <div style="display:flex; flex-direction:column; gap:12px; min-width:0;">
              <div class="chips small mono" id="dbBreadcrumb"></div>
              <div class="tabs" id="dbSetTabs"></div>
              <div id="dbSetDetails"></div>
              <div class="stack">
                <button class="btn hidden" id="dbQuickEditBtn" title="Quickly add cards and update location">Edit Card / Sealed Amount</button>
              </div>
              <div class="card hidden" id="dbImportCard">
                <div class="row">
                  <div class="small muted" id="dbImportTitle">Import into (Select Set)</div>
                </div>
                <div class="small muted">Destination: <span id="dbImportDestination">-</span></div>
                <div class="stack small space-top">
                  <input type="file" id="dbImportFile" accept=".txt,.json,.csv,application/json,text/plain">
                </div>
            <div class="stack small space-top">
              <button class="btn" id="dbImportAllBtn">Import All</button>
              <button class="btn ghost" id="dbImportPhotosBtn">Update Photos Only</button>
              <button class="btn ghost" id="dbImportPricesBtn">Update Prices Only</button>
            </div>
              </div>
              <div id="dbOutput"></div>
            </div>
          </div>
        </section>

        <section id="page-logs" class="page">
          <h2 class="section-title">Logs</h2>
          <div class="card" id="logsControls">
            <div class="logs-header">
              <button class="btn ghost small" id="logsRefreshBtn" style="padding:6px 8px;">Refresh</button>
            </div>
            <div class="logs-tabs" style="margin-top:8px;">
              <button class="tab-btn active" id="logsTabCards">Cards</button>
              <button class="tab-btn" id="logsTabSealed">Sealed</button>
            </div>
          </div>
          <div class="card space-top" id="logsListWrap">
            <div class="row">
              <div class="small muted">Recent Logs</div>
              <div class="small"><span id="logsCount">0</span></div>
            </div>
            <div class="divider"></div>
            <div id="logsList"><div class="small muted">Loading…</div></div>
          </div>
        </section>
      </main>
    </div>

    <!-- Quick Edit Modal -->
    <div id="quickEditModal" class="hidden">
      <div class="modal-backdrop">
        <div class="modal-panel">
          <div class="modal-header">
            <div class="row" style="gap:8px;justify-content:flex-start;">
              <div class="small muted">Quick Edit</div>
              <div class="chip" id="quickEditContext">Cards</div>
            </div>
            <button class="btn ghost small" id="quickEditClose" style="padding:6px 8px;">Close</button>
          </div>
          <div class="modal-body">
            <div id="quickEditRows"></div>
            <div class="small muted space-top">Leave rows blank to skip. If Location is blank, it will not be changed.</div>
          </div>
          <div class="modal-footer">
            <button class="btn secondary" id="quickEditCancel">Cancel</button>
            <button class="btn" id="quickEditApply">Apply Updates</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Add Set Modal -->
    <div id="addSetModal" class="hidden">
      <div class="modal-backdrop">
        <div class="modal-panel">
          <div class="modal-header">
            <div class="row" style="gap:8px;justify-content:flex-start;">
              <div class="small muted">Add New Set</div>
              <div class="chip" id="addSetContext">-</div>
            </div>
            <button class="btn ghost small" id="addSetClose" style="padding:6px 8px;">Close</button>
          </div>
          <div class="modal-body">
            <div class="grid-quick" style="grid-template-columns: 140px 1fr;">
              <div class="hdr" id="addSetCategoryLabel">Category</div>
              <input id="addSetCategory" placeholder="e.g., Scarlet and Violet">
              <div class="hdr">Set Name</div>
              <input id="addSetName" placeholder="e.g., Phantasmal Flames">
              <div class="hdr">Cards</div>
              <input id="addSetCards" type="number" min="0" step="1" placeholder="0">
              <div class="hdr">Total Cards</div>
              <input id="addSetTotalCards" type="number" min="0" step="1" placeholder="0">
              <div class="hdr">Image Link</div>
              <input id="addSetImage" placeholder="https://…">
              <div class="hdr">Flags</div>
              <div class="toggle-row">
                <label class="switch"><input type="checkbox" id="addSetCanImportCards"><span class="slider"></span></label>
                <span class="small">Can Import Cards</span>
                <label class="switch" style="margin-left:14px;"><input type="checkbox" id="addSetCanImportSealed"><span class="slider"></span></label>
                <span class="small">Can Import Sealed</span>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn secondary" id="addSetCancel">Cancel</button>
            <button class="btn" id="addSetApply">Create Set</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Add Category Modal -->
    <div id="addCategoryModal" class="hidden">
      <div class="modal-backdrop">
        <div class="modal-panel">
          <div class="modal-header">
            <div class="row" style="gap:8px;justify-content:flex-start;">
              <div class="small muted">Add New Category</div>
              <div class="chip" id="addCategoryContext">-</div>
            </div>
            <button class="btn ghost small" id="addCategoryClose" style="padding:6px 8px;">Close</button>
          </div>
          <div class="modal-body">
            <div class="grid-quick" style="grid-template-columns: 140px 1fr;">
              <div class="hdr">Category Name</div>
              <input id="addCategoryName" placeholder="e.g., Scarlet and Violet">
            </div>
            <div class="small muted space-top">A hidden placeholder will be created so this category shows in the tree.</div>
          </div>
          <div class="modal-footer">
            <button class="btn secondary" id="addCategoryCancel">Cancel</button>
            <button class="btn" id="addCategoryApply">Create Category</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const sdkStatus = document.getElementById('sdkStatus');
        const pages = {
          home: document.getElementById('page-home'),
          statistics: document.getElementById('page-statistics'),
          database: document.getElementById('page-database'),
          logs: document.getElementById('page-logs'),
          signin: document.getElementById('page-signin'),
        };
        const navLinks = {
          home: document.getElementById('nav-home'),
          statistics: document.getElementById('nav-statistics'),
          database: document.getElementById('nav-database'),
          logs: document.getElementById('nav-logs'),
          signin: document.getElementById('nav-signin'),
        };

        function setActiveNav(hash) {
          Object.values(navLinks).forEach(a => a.classList.remove('active'));
          if (hash === '#statistics') navLinks.statistics.classList.add('active');
          else if (hash === '#database') navLinks.database.classList.add('active');
          else if (hash === '#logs') navLinks.logs.classList.add('active');
          else if (hash === '#signin') navLinks.signin.classList.add('active');
          else navLinks.home.classList.add('active');
        }

        // Language overview: show Add Set even if no categories/sets exist
        async function showLanguageOverview(lang) {
          dbState.language = lang;
          dbState.category = '';
          dbState.setName = '';
          updateBreadcrumb();
          refreshImportCardContext();
          await refreshImportVisibility();
          if (dbSetTabs) {
            dbSetTabs.innerHTML = '';
            if (currentUserCanEdit) {
              const addCatBtn = document.createElement('button');
              addCatBtn.className = 'btn';
              addCatBtn.id = 'btnAddCategory';
              addCatBtn.textContent = 'Add Category';
              addCatBtn.addEventListener('click', openAddCategoryModal);
              dbSetTabs.appendChild(addCatBtn);
            }
          }
          if (dbSetDetails) { dbSetDetails.className = 'category-grid'; dbSetDetails.innerHTML = '<div class="small muted mono">Loading…</div>'; }
          if (dbOutput) { dbOutput.innerHTML = ''; }
          try {
            const struct = await discoverStructure();
            const categories = Object.keys(struct[lang] || {}).sort((a, b) => a.localeCompare(b));
            if (dbSetDetails) {
              dbSetDetails.innerHTML = '';
              const frag = document.createDocumentFragment();
              categories.forEach(cat => {
                const sets = Object.keys(struct[lang][cat] || {})
                  .filter(n => !/^_/.test(n))
                  .sort((a, b) => a.localeCompare(b));
                const card = document.createElement('div');
                card.className = 'card';
                const header = document.createElement('div');
                header.className = 'row';
                header.style.justifyContent = 'space-between';
                const title = document.createElement('div');
                title.className = 'mono';
                title.style.fontWeight = '600';
                title.textContent = cat;
                header.appendChild(title);
                if (currentUserCanEdit) {
                  const addBtn = document.createElement('button');
                  addBtn.className = 'btn ghost small';
                  addBtn.style.padding = '6px 8px';
                  addBtn.textContent = 'Add Set';
                  addBtn.addEventListener('click', () => { dbState.category = cat; openAddSetModal(); });
                  header.appendChild(addBtn);
                }
                card.appendChild(header);
                const ul = document.createElement('ul');
                ul.style.margin = '8px 0 0 0';
                ul.style.padding = '0 0 0 0';
                if (sets.length === 0) {
                  const li = document.createElement('li');
                  li.className = 'small muted';
                  li.textContent = 'No sets yet.';
                  ul.appendChild(li);
                } else {
                  sets.forEach(setName => {
                    const li = document.createElement('li');
                    li.className = 'set-item';
                    li.textContent = setName;
                    li.addEventListener('click', () => navigateToSet(lang, cat, setName));
                    ul.appendChild(li);
                  });
                }
                card.appendChild(ul);
                frag.appendChild(card);
              });
              if (categories.length === 0) {
                dbSetDetails.innerHTML = '<div class="card"><div class="small muted">No categories yet. Use "Add Category".</div></div>';
              } else {
                dbSetDetails.appendChild(frag);
              }
            }
          } catch (_) {}
        }

        function showPage(hash) {
          Object.values(pages).forEach(p => p.classList.remove('active'));
          if (hash === '#statistics') { pages.statistics.classList.add('active'); renderStatisticsCost(); }
          else if (hash === '#database') pages.database.classList.add('active');
          else if (hash === '#logs') { pages.logs.classList.add('active'); renderLogs('card'); }
          else if (hash === '#signin') pages.signin.classList.add('active');
          else pages.home.classList.add('active');
          setActiveNav(hash);
        }

        function bindNavClicks() {
          Object.entries(navLinks).forEach(([key, el]) => {
            el.addEventListener('click', (ev) => {
              ev.preventDefault();
              const targetHash = '#' + key;
              if (location.hash !== targetHash) {
                location.hash = targetHash;
              }
              showPage(targetHash);
            });
          });
        }

        function initRouter() {
          const initial = location.hash || '#home';
          showPage(initial);
          window.addEventListener('hashchange', () => showPage(location.hash || '#home'));
        }

        // Database UI
        const dbTree = document.getElementById('dbTree');
        const dbRefreshTree = document.getElementById('dbRefreshTree');
        const dbBreadcrumb = document.getElementById('dbBreadcrumb');
        const dbOutput = document.getElementById('dbOutput');
        const dbImportCardEl = document.getElementById('dbImportCard');
        const dbImportTitle = document.getElementById('dbImportTitle');
        const dbImportDestination = document.getElementById('dbImportDestination');
        const dbQuickEditBtn = document.getElementById('dbQuickEditBtn');
        const dbSetTabs = document.getElementById('dbSetTabs');
        const dbSetDetails = document.getElementById('dbSetDetails');
        if (dbImportCardEl) dbImportCardEl.classList.add('hidden');

        // Logs UI elements
        const logsControls = document.getElementById('logsControls');
        const logsList = document.getElementById('logsList');
        const logsCount = document.getElementById('logsCount');
        const logsRefreshBtn = document.getElementById('logsRefreshBtn');
        const logsTabCards = document.getElementById('logsTabCards');
        const logsTabSealed = document.getElementById('logsTabSealed');
        let logsView = 'card'; // card | sealed
        // Statistics UI elements
        const statsCostChartEl = document.getElementById('statsCostChart');
        const statsCostInfo = document.getElementById('statsCostInfo');
        const statsRangeTabs = document.getElementById('statsRangeTabs');
        let statsRange = '1M';
        let statsChart = null;
        let statsInitializedOnce = false;

        const dbState = {
          language: 'English',
          category: 'Mega Evolution',
          setName: '',
          view: 'Cards', // Cards | Sealed
        };
        let currentUserCanEdit = false;
        let currentCategorySets = { lang: '', cat: '', map: {} };
        let logsInitializedOnce = false;

        // --- Statistics helpers (cost over time) ---
        const STATS_RANGE_MS = {
          '1H': 60 * 60 * 1000,
          '1D': 24 * 60 * 60 * 1000,
          '7D': 7 * 24 * 60 * 60 * 1000,
          '1M': 30 * 24 * 60 * 60 * 1000,
          '6M': 182 * 24 * 60 * 60 * 1000,
          '1Y': 365 * 24 * 60 * 60 * 1000,
          'ALL': Number.POSITIVE_INFINITY
        };
        function setActiveStatsRange(r) {
          statsRange = r;
          if (statsRangeTabs) {
            Array.from(statsRangeTabs.querySelectorAll('button.tab-btn') || []).forEach(btn => {
              btn.classList.toggle('active', btn.getAttribute('data-range') === r);
            });
          }
        }
        function toMillis(ts) {
          try {
            if (!ts) return 0;
            if (typeof ts.toDate === 'function') return ts.toDate().getTime();
            if (typeof ts === 'number') return ts > 1e12 ? ts : ts * 1000;
            const d = new Date(ts);
            return Number.isNaN(d.getTime()) ? 0 : d.getTime();
          } catch (_) { return 0; }
        }
        // Caches reused between renders
        let cardCostMap = null;   // key: "Category / Set|Number|printNorm" -> cost
        let sealedCostMap = null; // key: "ProductName" -> cost
        let cachedTotalNow = null;
        async function ensureCostCachesAndTotal() {
          if (cardCostMap && sealedCostMap && Number.isFinite(cachedTotalNow)) return;
          const db = await getDb();
          cardCostMap = new Map();
          sealedCostMap = new Map();
          let total = 0;
          // Cards
          try {
            const snap = await db.collectionGroup('Cards').get();
            snap.forEach(doc => {
              const data = doc.data() || {};
              const parts = doc.ref.path.split('/');
              if (parts.length >= 6 && parts[0] === 'Pokemon Packs') {
                const cat = parts[2];
                const setName = parts[3];
                const number = Number(data['Number'] || 0);
                const printing = normalizePrintingLabel(data['Printing'] || '');
                const key = (cat + ' / ' + setName) + '|' + number + '|' + (printing || '');
                const cost = Number(data['Cost'] || 0) || 0;
                const owned = Number(data['Amount Owned'] || 0) || 0;
                cardCostMap.set(key, cost);
                if (Number.isFinite(cost) && Number.isFinite(owned)) {
                  total += cost * owned;
                }
              }
            });
          } catch (_) {}
          // Sealed
          try {
            const snap = await db.collectionGroup('Sealed').get();
            snap.forEach(doc => {
              const data = doc.data() || {};
              const name = doc.id;
              const cost = Number(data['Cost'] || 0) || 0;
              const owned = Number(data['Amount Owned'] || 0) || 0;
              sealedCostMap.set(name, cost);
              if (Number.isFinite(cost) && Number.isFinite(owned)) {
                total += cost * owned;
              }
            });
          } catch (_) {}
          cachedTotalNow = total;
        }
        function pickBucketSizeMs(rangeMs) {
          if (!Number.isFinite(rangeMs) || rangeMs === Number.POSITIVE_INFINITY) return 24 * 60 * 60 * 1000; // daily
          // Aim for <= 400 points
          const targetPoints = 400;
          const rough = Math.ceil(rangeMs / targetPoints);
          // Round to sensible units
          const minute = 60 * 1000;
          const hour = 60 * minute;
          const day = 24 * hour;
          const week = 7 * day;
          if (rough <= minute) return minute;
          if (rough <= 15 * minute) return 15 * minute;
          if (rough <= hour) return hour;
          if (rough <= 6 * hour) return 6 * hour;
          if (rough <= day) return day;
          if (rough <= week) return week;
          return 30 * day;
        }
        async function fetchLogDeltasSince(startMs) {
          const db = await getDb();
          const start = new Date(startMs);
          const now = new Date();
          const queries = [];
          try {
            if (Number.isFinite(startMs) && STATS_RANGE_MS[statsRange] !== Number.POSITIVE_INFINITY) {
              queries.push(db.collection('CardLogs').where('time', '>=', start).where('time', '<=', now).orderBy('time', 'asc').get());
              queries.push(db.collection('SealedLogs').where('time', '>=', start).where('time', '<=', now).orderBy('time', 'asc').get());
            } else {
              queries.push(db.collection('CardLogs').orderBy('time', 'asc').get());
              queries.push(db.collection('SealedLogs').orderBy('time', 'asc').get());
            }
          } catch (_) {
            // If index missing for range query, fallback to loading all and filtering client-side
            queries.length = 0;
            queries.push(db.collection('CardLogs').orderBy('time', 'asc').get());
            queries.push(db.collection('SealedLogs').orderBy('time', 'asc').get());
          }
          const [cardSnap, sealedSnap] = await Promise.all(queries);
          const deltas = [];
          // Cards: resolve cost via (set|number|print)
          if (cardSnap) {
            cardSnap.forEach(d => {
              const x = d.data() || {};
              const t = toMillis(x.time);
              if (Number.isFinite(startMs) && STATS_RANGE_MS[statsRange] !== Number.POSITIVE_INFINITY && t < startMs) return;
              if (Array.isArray(x.items)) {
                for (const it of x.items) {
                  const key = String(it.set || '') + '|' + Number(it.number || 0) + '|' + (normalizePrintingLabel(it.print || '') || '');
                  const cost = (cardCostMap && cardCostMap.get(key)) || 0;
                  const amt = Number(it.amount || 0) || 0;
                  if (!Number.isFinite(t)) continue;
                  const delta = cost * amt;
                  if (delta !== 0) deltas.push({ t, v: delta });
                }
              } else {
                const key = String(x.set || '') + '|' + Number(x.number || 0) + '|' + (normalizePrintingLabel(x.print || '') || '');
                const cost = (cardCostMap && cardCostMap.get(key)) || 0;
                const amt = Number(x.amount || 0) || 0;
                if (!Number.isFinite(t)) return;
                const delta = cost * amt;
                if (delta !== 0) deltas.push({ t, v: delta });
              }
            });
          }
          // Sealed: resolve cost via product name
          if (sealedSnap) {
            sealedSnap.forEach(d => {
              const x = d.data() || {};
              const t = toMillis(x.time);
              if (Number.isFinite(startMs) && STATS_RANGE_MS[statsRange] !== Number.POSITIVE_INFINITY && t < startMs) return;
              if (Array.isArray(x.items)) {
                for (const it of x.items) {
                  const name = String(it.sealedName || '');
                  const cost = (sealedCostMap && sealedCostMap.get(name)) || 0;
                  const amt = Number(it.amount || 0) || 0;
                  if (!Number.isFinite(t)) continue;
                  const delta = cost * amt;
                  if (delta !== 0) deltas.push({ t, v: delta });
                }
              } else {
                const name = String(x.sealedName || '');
                const cost = (sealedCostMap && sealedCostMap.get(name)) || 0;
                const amt = Number(x.amount || 0) || 0;
                if (!Number.isFinite(t)) return;
                const delta = cost * amt;
                if (delta !== 0) deltas.push({ t, v: delta });
              }
            });
          }
          return deltas;
        }
        function aggregateAndBucket(deltas, startMs, endMs) {
          const exact = new Map(); // key: ms -> sum delta
          for (const d of deltas) {
            const k = d.t;
            exact.set(k, (exact.get(k) || 0) + d.v);
          }
          const rangeMs = endMs - startMs;
          const bucketMs = pickBucketSizeMs(rangeMs);
          const bucketStart = (ms) => Math.floor(ms / bucketMs) * bucketMs;
          const buckets = new Map(); // key: ms bucket -> sum delta
          Array.from(exact.entries()).sort((a, b) => a[0] - b[0]).forEach(([t, v]) => {
            const b = bucketStart(t);
            buckets.set(b, (buckets.get(b) || 0) + v);
          });
          // Build time-ordered arrays and cumulative to absolute using baseline
          const times = Array.from(buckets.keys()).sort((a, b) => a - b);
          const deltasOrdered = times.map(t => buckets.get(t) || 0);
          return { times, deltasOrdered, bucketMs };
        }
        function computeAbsoluteSeries(times, deltas, baseline) {
          const values = [];
          let acc = Math.max(0, Number(baseline) || 0);
          for (let i = 0; i < times.length; i++) {
            acc += deltas[i];
            // Total collection cost cannot be negative; clamp to zero
            values.push(Math.max(0, acc));
          }
          return values;
        }
        function formatCurrency(n) {
          try { return new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(Number(n) || 0); } catch (_) { return '$' + (Number(n).toFixed ? Number(n).toFixed(2) : String(n)); }
        }
        async function renderStatisticsCost() {
          if (!statsCostChartEl) return;
          if (statsCostInfo) statsCostInfo.textContent = 'Loading…';
          await ensureCostCachesAndTotal();
          const nowMs = Date.now();
          const rangeMs = STATS_RANGE_MS[statsRange];
          const startMs = rangeMs === Number.POSITIVE_INFINITY ? 0 : (nowMs - rangeMs);
          const deltas = await fetchLogDeltasSince(startMs);
          // Total delta within window
          const totalDelta = deltas.reduce((s, d) => s + d.v, 0);
          const baseline = Math.max(0, Number.isFinite(cachedTotalNow) ? (cachedTotalNow - totalDelta) : 0);
          const { times, deltasOrdered } = aggregateAndBucket(deltas, startMs, nowMs);
          // For ALL, avoid epoch start; use earliest log time if present
          const effectiveStartMs = (rangeMs === Number.POSITIVE_INFINITY && times.length > 0) ? times[0] : (rangeMs === Number.POSITIVE_INFINITY ? nowMs - 365 * 24 * 60 * 60 * 1000 : startMs);
          // Ensure we always render at least two points for uPlot
          const xsMs = times.length > 0 ? times : [effectiveStartMs, nowMs];
          const ys = times.length > 0 ? computeAbsoluteSeries(times, deltasOrdered, baseline) : [baseline, cachedTotalNow || baseline];
          // Build ApexCharts data points
          const points = xsMs.map((t, i) => ({ x: t, y: ys[i] }));
          const xMin = (rangeMs === Number.POSITIVE_INFINITY) ? effectiveStartMs : startMs;
          const xMax = nowMs;
          // Initialize or update chart (ApexCharts)
          const opts = {
            chart: { type: 'line', height: 320, width: '100%', parentHeightOffset: 0, animations: { enabled: false }, toolbar: { show: false } },
            stroke: { width: 2, curve: 'straight' },
            series: [{ name: 'Total Cost', data: points }],
            xaxis: { type: 'datetime', min: xMin, max: xMax, crosshairs: { show: false }, tooltip: { enabled: false } },
            yaxis: { min: 0, decimalsInFloat: 2, labels: { formatter: (v) => formatCurrency(v) } },
            grid: { show: true },
            tooltip: {
              x: { formatter: (val) => new Date(val).toLocaleString() },
              y: { formatter: (val) => formatCurrency(val) },
              fixed: { enabled: false }
            },
            markers: { size: 3 }
          };
          try {
            if (!statsChart) {
              statsChart = new (window.ApexCharts || function(){}) (statsCostChartEl, opts);
              if (statsChart && statsChart.render) await statsChart.render();
              // ApexCharts handles responsive width automatically
            } else {
              try {
                await statsChart.updateOptions({ chart: { height: 320 }, xaxis: { min: xMin, max: xMax } }, false, true);
                await statsChart.updateSeries([{ name: 'Total Cost', data: points }], true);
              } catch (_) {}
            }
          } catch (_) {
            // Fallback: simple text if uPlot not available
            statsCostChartEl.innerHTML = '<div class="small muted">Chart unavailable.</div>';
          }
          if (statsCostInfo) {
            const first = xsMs[0];
            const last = xsMs[xsMs.length - 1];
            const startLabel = new Date(first).toLocaleString();
            const endLabel = new Date(last).toLocaleString();
            const totalNowFmt = formatCurrency(cachedTotalNow || 0);
            statsCostInfo.textContent = 'Range: ' + startLabel + ' → ' + endLabel + ' • Current total: ' + totalNowFmt + ' • Points: ' + xsMs.length;
          }
          if (!statsInitializedOnce) statsInitializedOnce = true;
        }
        if (statsRangeTabs) {
          statsRangeTabs.addEventListener('click', (e) => {
            const t = e.target;
            if (t && t.matches('button.tab-btn')) {
              const r = t.getAttribute('data-range') || '1M';
              setActiveStatsRange(r);
              renderStatisticsCost();
            }
          });
        }

        function updateBreadcrumb() {
          const parts = [
            'Pokemon Packs',
            dbState.language,
            dbState.category,
            dbState.setName || '(Select Set)',
            dbState.view,
          ];
          dbBreadcrumb.innerHTML = '';
          parts.forEach((p, idx) => {
            const el = document.createElement('span');
            el.className = 'chip' + (idx === parts.length - 1 ? ' active' : '');
            el.textContent = p;
            dbBreadcrumb.appendChild(el);
          });
        }

        function normalizeValueForCell(value) {
          if (value === null || value === undefined) return '';
          if (typeof value === 'object') {
            try { return JSON.stringify(value); } catch { return String(value); }
          }
          return String(value);
        }

        async function loadCards() {
          const db = await getDb();
          dbOutput.innerHTML = '<div class="small muted mono">Loading cards…</div>';
          try {
            const colRef = db.collection('Pokemon Packs')
              .doc(dbState.language)
              .collection(dbState.category)
              .doc(dbState.setName)
              .collection('Cards');
            const snap = await colRef.get();
            const rows = [];
            const fieldSet = new Set(['Number', 'Amount Owned', 'Cost', 'Location', 'Wishlist']);
            snap.forEach(doc => {
              const data = doc.data() || {};
              Object.keys(data || {}).forEach(k => fieldSet.add(k));
              rows.push({ id: doc.id, data });
            });
            const fields = Array.from(fieldSet);
            // Desired column order
            const preferredOrder = ['Number', 'Printing', 'Rarity', 'Cost', 'Location', 'Amount Owned'];
            // Build fields to show strictly following the preferred order and excluding hidden fields
            const hiddenFields = new Set(['Picture Link', 'Wishlist']);
            const fieldsForTable = preferredOrder.filter(f => fields.includes(f) && !hiddenFields.has(f));
            let html = '';
            html += '<div class="card" style="overflow:auto;">';
            html += '<table class="table">';
            html += '<thead><tr><th>Pokemon</th>' + fieldsForTable.map(f => '<th>' + f + '</th>').join('') + '</tr></thead>';
            html += '<tbody>';
            rows.sort((a, b) => {
              const toNumber = (val) => {
                const n = Number(val);
                return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
              };
              const na = toNumber(a.data['Number']);
              const nb = toNumber(b.data['Number']);
              if (na !== nb) return na - nb;
              return a.id.localeCompare(b.id);
            });
            rows.forEach(row => {
              html += '<tr>';
              const pic = String((row.data && row.data['Picture Link']) || '').trim();
              const img = pic ? '<span class="thumb-wrap"><img class="card-thumb" src="' + pic + '" alt="' + row.id + '"></span>' : '';
              const displayName = String((row.data && row.data['Name']) || row.id || '');
              html += '<td class="mono">' + img + displayName + '</td>';
              fieldsForTable.forEach(f => {
                const v = normalizeValueForCell(row.data[f]);
                html += '<td>' + v + '</td>';
              });
              html += '</tr>';
            });
            html += '</tbody></table></div>';
            if (rows.length === 0) {
              html = '<div class="card"><div class="small muted">No cards found.</div></div>';
            }
            dbOutput.innerHTML = html;
          } catch (e) {
            dbOutput.innerHTML = '<div class="card"><div class="small mono" style="color:#C53030;">Failed to load cards: ' + (e && e.message ? e.message : String(e)) + '</div></div>';
          }
        }

        async function loadSealed() {
          const db = await getDb();
          dbOutput.innerHTML = '<div class="small muted mono">Loading sealed items…</div>';
          try {
            const colRef = db.collection('Pokemon Packs')
              .doc(dbState.language)
              .collection(dbState.category)
              .doc(dbState.setName)
              .collection('Sealed');
            const snap = await colRef.get();
            const rows = [];
            const fieldSet = new Set(['Number', 'Count', 'Cost', 'Location', 'Amount Owned']);
            snap.forEach(doc => {
              const data = doc.data() || {};
              Object.keys(data || {}).forEach(k => fieldSet.add(k));
              rows.push({ id: doc.id, data });
            });
            // Build fields in preferred order and hide image/link fields
            const hidden = new Set(['Picture', 'Picture Link', 'Link', 'Count', 'Number']);
            const fields = Array.from(fieldSet).filter(f => !hidden.has(f));
            const preferredOrder = ['Cost', 'Location', 'Amount Owned'];
            fields.sort((a, b) => {
              const ai = preferredOrder.indexOf(a);
              const bi = preferredOrder.indexOf(b);
              if (ai !== -1 && bi !== -1) return ai - bi;
              if (ai !== -1) return -1;
              if (bi !== -1) return 1;
              return a.localeCompare(b);
            });
            // Render table similar to Cards view
            let html = '';
            html += '<div class="card" style="overflow:auto;">';
            html += '<table class="table">';
            html += '<thead><tr><th>Product</th>' + fields.map(f => '<th>' + f + '</th>').join('') + '</tr></thead>';
            html += '<tbody>';
            // Sort by product name (document id)
            rows.sort((a, b) => a.id.localeCompare(b.id));
            rows.forEach(row => {
              const data = row.data || {};
              html += '<tr>';
              const pic = String((data['Picture Link'] || data['Picture'] || '')).trim();
              const img = pic ? '<span class="thumb-wrap"><img class="card-thumb" src="' + pic + '" alt="' + row.id + '"></span>' : '';
              const displayName = String(row.id || '');
              html += '<td class="mono">' + img + displayName + '</td>';
              fields.forEach(f => {
                const v = normalizeValueForCell(data[f]);
                html += '<td>' + v + '</td>';
              });
              html += '</tr>';
            });
            html += '</tbody></table></div>';
            if (rows.length === 0) {
              html = '<div class="card"><div class="small muted">No sealed items found.</div></div>';
            }
            dbOutput.innerHTML = html;
          } catch (e) {
            dbOutput.innerHTML = '<div class="card"><div class="small mono" style="color:#C53030;">Failed to load sealed items: ' + (e && e.message ? e.message : String(e)) + '</div></div>';
          }
        }

        async function loadCurrentView() {
          updateBreadcrumb();
          refreshImportCardContext();
          await refreshImportVisibility();
          // Ensure "Add Set" controls are only visible at category level (clear in set/leaf views)
          if (dbSetTabs) { dbSetTabs.innerHTML = ''; }
          // Clear any overview cards when viewing leaf data
          if (dbSetDetails) { dbSetDetails.innerHTML = ''; }
          if (!dbState.setName) { dbOutput.innerHTML = ''; return; }
          if (dbState.view === 'Cards') {
            await loadCards();
          } else {
            await loadSealed();
          }
        }

        function buildDataPathForCurrentSet() {
          if (!dbState.setName) return '';
          const cat = encodeURIComponent(dbState.category || '');
          const set = encodeURIComponent(dbState.setName || '');
          return '/data/' + cat + '/' + set + '.txt';
        }

        function refreshImportCardContext() {
          if (dbImportTitle) {
            const setLabel = dbState.setName || '(Select Set)';
            const target = (dbState.view || 'Cards');
            dbImportTitle.textContent = 'Import into ' + (dbState.category || '') + ' / ' + setLabel + ' / ' + target;
          }
          if (dbImportDestination) {
            const parts = [(dbState.category || ''), (dbState.setName || ''), (dbState.view || 'Cards')].filter(Boolean);
            dbImportDestination.textContent = parts.join(' / ') || '-';
          }
        }

        // Read set-level import flags from the current set document
        async function isSetImportAllowed() {
          if (!dbState.setName) return false;
          try {
            const db = await getDb();
            const setRef = db
              .collection('Pokemon Packs')
              .doc(dbState.language || 'English')
              .collection(dbState.category || 'Mega Evolution')
              .doc(dbState.setName);
            const snap = await setRef.get();
            const data = snap && snap.exists ? (snap.data() || {}) : {};
            if (dbState.view === 'Cards') {
              return data.CanImportCards === true;
            } else if (dbState.view === 'Sealed') {
              return data.CanImportSealed === true;
            }
            return false;
          } catch (_) {
            return false;
          }
        }

        // Make a Firestore-safe document id (no '/')
        function makeSafeDocId(raw) {
          const s = String(raw || '').trim();
          if (!s) return '';
          return s
            .replace(/\//g, '-')   // Firestore doc ids cannot contain '/'
            .replace(/^\s+|\s+$/g, '')
            .slice(0, 300);        // conservative cap
        }

        // Allow/deny specific sets for import
        function canImportCurrentSet() {
          const name = String(dbState.setName || '').trim();
          const category = String(dbState.category || '').trim();
          // Blocklist: sets that should NOT be importable
          const blocked = new Set(['Base Set']);
          if (!name) return false;
          if (blocked.has(name)) return false;
          // Otherwise allowed (e.g., "Phantasmal Flames")
          return true;
        }

        // Toggle visibility of import UI based on Users/{uid} flags and set-level flags
        async function refreshImportVisibility() {
          try {
            const firebaseGlobal = window.firebase;
            if (!firebaseGlobal || !firebaseGlobal.auth) return;
            if (!dbImportCardEl) return;
            const user = firebaseGlobal.auth().currentUser;
            if (!user) {
              dbImportCardEl.classList.add('hidden');
              if (dbQuickEditBtn) dbQuickEditBtn.classList.add('hidden');
              return;
            }
            const db = await getDb();
            const doc = await db.collection('Users').doc(user.uid).get();
            const data = doc && doc.exists ? (doc.data() || {}) : {};
            const userAllowed = !!(data && data.canEdit === true);
            currentUserCanEdit = userAllowed;
            refreshLogsVisibility();
            const setAllowed = await isSetImportAllowed();
            const allowed = userAllowed && setAllowed;
            dbImportCardEl.classList.toggle('hidden', !allowed);
            refreshImportCardContext();
            // Show quick edit button for editors when a set is selected
            if (dbQuickEditBtn) {
              const showQuick = userAllowed && !!dbState.setName;
              dbQuickEditBtn.classList.toggle('hidden', !showQuick);
            }
          } catch (_) {
            if (dbImportCardEl) dbImportCardEl.classList.add('hidden');
            if (dbQuickEditBtn) dbQuickEditBtn.classList.add('hidden');
          }
        }

        // --- Tree UI ---
        function makeTreeNode(label, options) {
          const hasChildren = !!(options && options.loadChildren);
          const node = document.createElement('div');
          node.className = 'tree-node';
          const row = document.createElement('div');
          row.className = 'tree-row';
          if (hasChildren) {
            const caret = document.createElement('span');
            caret.className = 'tree-caret';
            row.appendChild(caret);
            // Only the caret toggles expand/collapse
            caret.addEventListener('click', async (ev) => {
              ev.stopPropagation();
              await toggle();
            });
          } else {
            const spacer = document.createElement('span');
            spacer.style.width = '6px';
            spacer.style.display = 'inline-block';
            row.appendChild(spacer);
          }
          const labelEl = document.createElement('span');
          labelEl.className = 'tree-label';
          labelEl.textContent = label;
          row.appendChild(labelEl);
          node.appendChild(row);
          const children = document.createElement('div');
          children.className = 'tree-children hidden';
          node.appendChild(children);

          let loaded = false;
          let expanded = false;
          const toggle = async () => {
            if (!hasChildren) return;
            expanded = !expanded;
            node.classList.toggle('expanded', expanded);
            children.classList.toggle('hidden', !expanded);
            if (expanded && !loaded) {
              loaded = true;
              if (options && typeof options.loadChildren === 'function') {
                await options.loadChildren(children);
              }
            }
          };
          // Clicking the row (label area) performs selection only
          row.addEventListener('click', async () => {
            if (options && typeof options.onSelect === 'function') {
              await options.onSelect();
            }
          });
          return { node, children, toggle };
        }

        // --- Category (3rd level) view: set tabs + summary header ---
        async function showCategoryOverview(lang, cat) {
          dbState.language = lang;
          dbState.category = cat;
          dbState.setName = '';
          updateBreadcrumb();
          refreshImportCardContext();
          await refreshImportVisibility();
          if (dbOutput) { dbOutput.innerHTML = ''; }
          if (dbSetDetails) { dbSetDetails.innerHTML = ''; dbSetDetails.className = 'set-grid'; }
          if (dbSetTabs) {
            dbSetTabs.innerHTML = '';
            if (currentUserCanEdit) {
              const addBtn = document.createElement('button');
              addBtn.className = 'btn';
              addBtn.id = 'btnAddSet';
              addBtn.textContent = 'Add Set';
              addBtn.addEventListener('click', openAddSetModal);
              dbSetTabs.appendChild(addBtn);
            }
          }
          try {
            const db = await getDb();
            const colRef = db.collection('Pokemon Packs').doc(lang).collection(cat);
            const snap = await colRef.get();
            const setsMap = {};
            const names = [];
            snap.forEach(d => {
              names.push(d.id);
              setsMap[d.id] = d.data() || {};
            });
            names.sort((a, b) => a.localeCompare(b));
            // Hide placeholder sets (ids starting with "_")
            const visibleNames = names.filter(n => !/^_/.test(n));
            currentCategorySets = { lang, cat, map: setsMap };
            // Render full overview cards for each set
            if (dbSetDetails) {
              const frag = document.createDocumentFragment();
              visibleNames.forEach(name => {
                const data = setsMap[name] || {};
                const card = createSetOverviewCard(name, data, lang, cat);
                frag.appendChild(card);
              });
              dbSetDetails.appendChild(frag);
            }
          } catch (e) {
            if (dbSetDetails) dbSetDetails.innerHTML = '<div class="small mono" style="color:#C53030;">Failed to load sets: ' + (e && e.message ? e.message : String(e)) + '</div>';
          }
        }

        function getSafe(obj, keys, fallback) {
          for (const k of keys) {
            if (obj && Object.prototype.hasOwnProperty.call(obj, k)) return obj[k];
          }
          return fallback;
        }

        function createSetOverviewCard(name, data, lang, cat) {
          const cardsCount = Number(getSafe(data, ['Cards', 'cards'], '')) || 0;
          const totalCards = Number(getSafe(data, ['Total Cards', 'TotalCards', 'totalCards'], '')) || 0;
          const imgUrl = String(getSafe(data, ['image', 'Image', 'Picture', 'Picture Link'], '') || '').trim();
          const canImportCards = !!getSafe(data, ['CanImportCards'], false);
          const canImportSealed = !!getSafe(data, ['CanImportSealed'], false);
          const wrapper = document.createElement('div');
          wrapper.className = 'card';
          wrapper.innerHTML =
            '<div class="set-overview">'
              + '<div style="flex:1;">'
                + '<div class="mono" style="font-weight:600;margin-bottom:6px;">' + name.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>'
                + '<ul class="kv-list">'
                  + '<li class="kv-item"><span class="kv-label small">Cards</span><span class="mono">' + cardsCount + '</span></li>'
                  + '<li class="kv-item"><span class="kv-label small">Total Cards</span><span class="mono">' + totalCards + '</span></li>'
                + '</ul>'
                + (currentUserCanEdit
                  ? ('<div class="space-top">'
                    + '<div class="toggle-row"><label class="switch"><input type="checkbox" class="set-flag" data-flag="CanImportCards"' + (canImportCards ? ' checked' : '') + '><span class="slider"></span></label><span class="small">Can Import Cards</span></div>'
                    + '<div class="toggle-row"><label class="switch"><input type="checkbox" class="set-flag" data-flag="CanImportSealed"' + (canImportSealed ? ' checked' : '') + '><span class="slider"></span></label><span class="small">Can Import Sealed</span></div>'
                  + '</div>')
                  : '')
              + '</div>'
              + '<img class="set-image" src="' + (imgUrl || '') + '" alt="' + name.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '">'
            + '</div>';
          // Click to select set (ignore clicks on toggles)
          wrapper.addEventListener('click', async (ev) => {
            const target = ev.target;
            if (target && (target.tagName === 'INPUT' || target.closest && target.closest('.switch'))) return;
            await selectSetFromTabs(name);
          });
          // Wire flag updates
          if (currentUserCanEdit) {
            const inputs = Array.from(wrapper.querySelectorAll('input.set-flag'));
            inputs.forEach(input => {
              input.addEventListener('change', async () => {
                const key = String(input.getAttribute('data-flag') || '');
                try {
                  const db = await getDb();
                  const ref = db.collection('Pokemon Packs').doc(lang).collection(cat).doc(name);
                  await ref.set({ [key]: !!input.checked }, { merge: true });
                  // Keep local cache in sync
                  if (currentCategorySets.map && currentCategorySets.map[name]) {
                    currentCategorySets.map[name][key] = !!input.checked;
                  }
                  // If this is the selected set, refresh import visibility
                  if (dbState.setName === name) await refreshImportVisibility();
                } catch (e) {
                  alert('Failed to update ' + key + ': ' + (e && e.message ? e.message : String(e)));
                  input.checked = !input.checked; // revert
                }
              });
            });
          }
          return wrapper;
        }

        async function renderSetDetails(name) {
          // Hide any category-level controls like "Add Set" in set-level view
          if (dbSetTabs) { dbSetTabs.innerHTML = ''; }
          const dataLocal = (currentCategorySets.map && currentCategorySets.map[name]) || {};
          let data = dataLocal;
          if (!('Cards' in dataLocal) && !('Total Cards' in dataLocal) && !('image' in dataLocal)) {
            try {
              const db = await getDb();
              const snap = await db.collection('Pokemon Packs').doc(dbState.language).collection(dbState.category).doc(name).get();
              data = snap && snap.exists ? (snap.data() || {}) : {};
            } catch (_) {}
          }
          const cardsCount = Number(getSafe(data, ['Cards', 'cards'], '')) || 0;
          const totalCards = Number(getSafe(data, ['Total Cards', 'TotalCards', 'totalCards'], '')) || 0;
          const imgUrl = String(getSafe(data, ['image', 'Image', 'Picture', 'Picture Link'], '') || '').trim();
          const canImportCards = !!getSafe(data, ['CanImportCards'], false);
          const canImportSealed = !!getSafe(data, ['CanImportSealed'], false);
          const parts = [];
          parts.push('<div class="card">');
          parts.push('<div class="set-overview">');
          parts.push('<div style="flex:1;">');
          parts.push('<ul class="kv-list">');
          parts.push('<li class="kv-item"><span class="kv-label small">Cards</span><span class="mono">' + cardsCount + '</span></li>');
          parts.push('<li class="kv-item"><span class="kv-label small">Total Cards</span><span class="mono">' + totalCards + '</span></li>');
          parts.push('</ul>');
          if (currentUserCanEdit) {
            parts.push('<div class="space-top">');
            parts.push('<div class="toggle-row"><label class="switch"><input type="checkbox" id="toggleCanImportCards"' + (canImportCards ? ' checked' : '') + '><span class="slider"></span></label><span class="small">Can Import Cards</span></div>');
            parts.push('<div class="toggle-row"><label class="switch"><input type="checkbox" id="toggleCanImportSealed"' + (canImportSealed ? ' checked' : '') + '><span class="slider"></span></label><span class="small">Can Import Sealed</span></div>');
            parts.push('</div>');
          }
          parts.push('</div>'); // left column
          parts.push('<img class="set-image" src="' + (imgUrl || '') + '" alt="' + name.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '">');
          parts.push('</div>'); // set-overview
          parts.push('</div>'); // card
          if (dbSetDetails) dbSetDetails.innerHTML = parts.join('');
          // Default: Cards view is already loaded by the caller
          const t1 = document.getElementById('toggleCanImportCards');
          const t2 = document.getElementById('toggleCanImportSealed');
          async function updateFlag(key, value) {
            try {
              const db = await getDb();
              const ref = db.collection('Pokemon Packs').doc(dbState.language).collection(dbState.category).doc(dbState.setName);
              await ref.set({ [key]: !!value }, { merge: true });
              await refreshImportVisibility();
            } catch (e) {
              alert('Failed to update ' + key + ': ' + (e && e.message ? e.message : String(e)));
            }
          }
          if (t1) t1.addEventListener('change', () => updateFlag('CanImportCards', !!t1.checked));
          if (t2) t2.addEventListener('change', () => updateFlag('CanImportSealed', !!t2.checked));
        }

        async function selectSetFromTabs(name) {
          dbState.setName = name;
          dbState.view = 'Cards';
          updateBreadcrumb();
          refreshImportCardContext();
          await refreshImportVisibility();
          if (dbSetTabs) {
            const children = Array.from(dbSetTabs.children || []);
            children.forEach(ch => ch.classList.toggle('active', (ch.textContent || '') === name));
          }
          await renderSetDetails(name);
          await loadCurrentView();
        }

        async function navigateToSet(lang, cat, setName) {
          dbState.language = lang;
          dbState.category = cat;
          dbState.setName = setName;
          dbState.view = 'Cards';
          updateBreadcrumb();
          refreshImportCardContext();
          await refreshImportVisibility();
          await renderSetDetails(setName);
          await loadCurrentView();
        }

        async function discoverStructure() {
          const db = await getDb();
          // shape: { [language]: { [category]: { [setName]: { hasCards, hasSealed }}}}
          const struct = {};
          const ensure = (lang, cat, set) => {
            struct[lang] = struct[lang] || {};
            struct[lang][cat] = struct[lang][cat] || {};
            struct[lang][cat][set] = struct[lang][cat][set] || { hasCards: false, hasSealed: false };
            return struct[lang][cat][set];
          };
          // Cards
          try {
            const snap = await db.collectionGroup('Cards').get();
            snap.forEach(doc => {
              const parts = doc.ref.path.split('/');
              // ["Pokemon Packs", lang, category, setName, "Cards", docId]
              if (parts.length >= 6 && parts[0] === 'Pokemon Packs') {
                const lang = parts[1];
                const cat = parts[2];
                const setName = parts[3];
                ensure(lang, cat, setName).hasCards = true;
              }
            });
          } catch (_) {}
          // Sealed
          try {
            const snap = await db.collectionGroup('Sealed').get();
            snap.forEach(doc => {
              const parts = doc.ref.path.split('/');
              if (parts.length >= 6 && parts[0] === 'Pokemon Packs') {
                const lang = parts[1];
                const cat = parts[2];
                const setName = parts[3];
                ensure(lang, cat, setName).hasSealed = true;
              }
            });
          } catch (_) {}
          // Also include languages that exist even if empty (best-effort)
          try {
            const langs = await db.collection('Pokemon Packs').get();
            langs.forEach(d => {
              if (d.id !== 'Users') struct[d.id] = struct[d.id] || {};
            });
          } catch (_) {}
          return struct;
        }

        async function buildDbTree() {
          if (!dbTree) return;
          dbTree.innerHTML = '';
          // Root -> Languages discovered dynamically from existing data
          const struct = await discoverStructure();
          const { node: rootNode, children: rootChildren, toggle: toggleRoot } = makeTreeNode('Pokemon Packs', {
            loadChildren: async (container) => {
              container.innerHTML = '';
              const languages = Object.keys(struct).sort((a, b) => a.localeCompare(b));
              if (languages.length === 0) {
                container.innerHTML = '<div class="small muted" style="padding:6px 8px;">No data found.</div>';
                return;
              }
              for (const lang of languages) {
                const categories = Object.keys(struct[lang] || {}).sort((a, b) => a.localeCompare(b));
                const { node: langNode, children: langChildren, toggle: toggleLang } = makeTreeNode(lang, {
                  onSelect: async () => { await showLanguageOverview(lang); },
                  loadChildren: async (container2) => {
                    container2.innerHTML = '';
                    if (categories.length === 0) {
                      container2.innerHTML = '<div class="small muted" style="padding:6px 8px;">No categories.</div>';
                      return;
                    }
                    for (const cat of categories) {
                      const setsMap = struct[lang][cat] || {};
                      // Filter out placeholder sets (ids starting with "_")
                      const setNames = Object.keys(setsMap)
                        .filter(n => !/^_/.test(n))
                        .sort((a, b) => a.localeCompare(b));
                      const { node: catNode, children: catChildren, toggle: toggleCat } = makeTreeNode(cat, {
                        onSelect: async () => { await showCategoryOverview(lang, cat); },
                        loadChildren: async (container3) => {
                          container3.innerHTML = '';
                          if (setNames.length === 0) {
                            container3.innerHTML = '<div class="small muted" style="padding:6px 8px;">No sets.</div>';
                            return;
                          }
                          for (const setName of setNames) {
                            const flags = setsMap[setName] || { hasCards: true, hasSealed: true };
                            const { node: setNode, children: setChildren, toggle: toggleSet } = makeTreeNode(setName, {
                              onSelect: async () => {
                                dbState.language = lang;
                                dbState.category = cat;
                                dbState.setName = setName;
                                dbState.view = 'Cards';
                                updateBreadcrumb();
                                await renderSetDetails(setName);
                                await loadCurrentView();
                              },
                              loadChildren: async (container4) => {
                                container4.innerHTML = '';
                                if (flags.hasCards) {
                                  const cardsNode = makeTreeNode('Cards', {
                                    onSelect: async () => {
                                      dbState.language = lang;
                                      dbState.category = cat;
                                      dbState.setName = setName;
                                      dbState.view = 'Cards';
                                      updateBreadcrumb();
                                      await loadCurrentView();
                                    }
                                  }).node;
                                  container4.appendChild(cardsNode);
                                }
                                if (flags.hasSealed) {
                                  const sealedNode = makeTreeNode('Sealed', {
                                    onSelect: async () => {
                                      dbState.language = lang;
                                      dbState.category = cat;
                                      dbState.setName = setName;
                                      dbState.view = 'Sealed';
                                      updateBreadcrumb();
                                      await loadCurrentView();
                                    }
                                  }).node;
                                  container4.appendChild(sealedNode);
                                }
                              }
                            });
                            container3.appendChild(setNode);
                            // Auto-expand set to reveal leaf nodes
                            try { await toggleSet(); } catch (_) {}
                          }
                        }
                      });
                      container2.appendChild(catNode);
                      // Auto-expand category to reveal sets
                      try { await toggleCat(); } catch (_) {}
                    }
                  }
                });
                rootChildren.appendChild(langNode);
                // Auto-expand language to reveal categories
                try { await toggleLang(); } catch (_) {}
              }
            }
          });
          dbTree.appendChild(rootNode);
          // Expand root by default
          await toggleRoot();
        }

        // Auth UI
        const signOutBtn = document.getElementById('signOut');
        const authStatus = document.getElementById('authStatus');
        // Auth pages elements
        const signinUsername = document.getElementById('signinUsername');
        const signinPassword = document.getElementById('signinPassword');
        const signinSubmit = document.getElementById('signinSubmit');
        const signupSubmit = document.getElementById('signupSubmit');

        function usernameToEmail(username) {
          const clean = String(username || '').trim().toLowerCase();
          if (!clean) return '';
          return clean + '@example.com';
        }

        async function fetchClientIp() {
          try {
            const res = await fetch('https://api.ipify.org?format=json');
            const data = await res.json();
            return data && data.ip ? data.ip : '';
          } catch {
            return '';
          }
        }

        async function upsertAccountProfile(user) {
          if (!user) return;
          const db = await getDb();
          const ip = await fetchClientIp();
          const accountRef = db.collection('Users').doc(user.uid);
          const now = (window.firebase && window.firebase.firestore && window.firebase.firestore.FieldValue && window.firebase.firestore.FieldValue.serverTimestamp) ? window.firebase.firestore.FieldValue.serverTimestamp() : null;
          let existing = null;
          try {
            existing = await accountRef.get();
          } catch (_) {}
          const existingData = existing && existing.exists ? existing.data() : {};
          const toSet = {
            username: existingData.username || (user.email ? user.email.split('@')[0] : ''),
            ip: ip || existingData.ip || '',
            lastVisit: now || existingData.lastVisit || null,
            canEdit: typeof existingData.canEdit === 'boolean' ? existingData.canEdit : false,
            createdAt: existingData.createdAt || (now || new Date()),
          };
          await accountRef.set(toSet, { merge: true });
        }

        // Database functions removed

        async function getDb() {
          const firebaseGlobal = window.firebase;
          if (!firebaseGlobal) {
            throw new Error('Firebase SDK not loaded.');
          }
          const db = firebaseGlobal.firestore();
          // Optionally use Firestore emulator if explicitly enabled
          try {
            if (window.__USE_FIRESTORE_EMULATOR__ === true) {
              const host = (window.__FIRESTORE_EMULATOR_HOST__ || '127.0.0.1');
              const port = Number(window.__FIRESTORE_EMULATOR_PORT__ || 8080);
              if (typeof db.useEmulator === 'function') {
                db.useEmulator(host, port);
              } else if (firebaseGlobal.firestore && typeof firebaseGlobal.firestore().useEmulator === 'function') {
                firebaseGlobal.firestore().useEmulator(host, port);
              }
              sdkStatus.textContent = (sdkStatus.textContent || '') + ' (Firestore emulator ' + host + ':' + port + ')';
            }
          } catch (_) {}
          return db;
        }

        // Database-specific helpers and events removed

        // Initialize
        try {
          const firebaseGlobal = window.firebase;
          if (!firebaseGlobal) {
            sdkStatus.textContent = 'Firebase SDK not loaded (global missing).';
          } else {
            const alreadyInitialized = Array.isArray(firebaseGlobal.apps) ? firebaseGlobal.apps.length > 0 : false;
            const app = alreadyInitialized
              ? firebaseGlobal.app()
              : (window.__FIREBASE_CONFIG__ ? firebaseGlobal.initializeApp(window.__FIREBASE_CONFIG__) : null);
            // Optional: enable analytics if available
            if (typeof firebaseGlobal.analytics === 'function') {
              try { firebaseGlobal.analytics(); } catch (_) {}
            }
            // Auth state
            try {
              const auth = firebaseGlobal.auth();
              auth.onAuthStateChanged(async user => {
                if (user) {
                  authStatus.textContent = 'Signed in as ' + (user.email ? user.email.split('@')[0] : user.uid);
                  signOutBtn.classList.remove('hidden');
                  if (navLinks.signin) navLinks.signin.style.display = 'none';
                  await upsertAccountProfile(user);
                  await refreshImportVisibility();
                } else {
                  authStatus.textContent = 'Signed out';
                  signOutBtn.classList.add('hidden');
                  if (navLinks.signin) navLinks.signin.style.display = '';
                  await refreshImportVisibility();
                }
              });
            } catch (_) {}

            signOutBtn.addEventListener('click', async () => {
              try {
                await firebaseGlobal.auth().signOut();
              } catch (e) {
                alert('Sign-out failed: ' + (e && e.message ? e.message : String(e)));
              }
            });
            // Sign-in page
            if (signinSubmit) {
              signinSubmit.addEventListener('click', async () => {
                const uname = (signinUsername && signinUsername.value || '').trim();
                const pwd = (signinPassword && signinPassword.value || '').trim();
                if (!uname || !pwd) {
                  alert('Enter username and password');
                  return;
                }
                try {
                  await firebaseGlobal.auth().signInWithEmailAndPassword(usernameToEmail(uname), pwd);
                  location.hash = '#home';
                } catch (e) {
                  alert('Sign-in failed: ' + (e && e.message ? e.message : String(e)));
                }
              });
            }
            // Create account action on same page
            if (signupSubmit) {
              signupSubmit.addEventListener('click', async () => {
                const uname = (signinUsername && signinUsername.value || '').trim().toLowerCase();
                const pwd = (signinPassword && signinPassword.value || '').trim();
                if (!uname || !pwd) {
                  alert('Enter username and password');
                  return;
                }
                if (!/^[a-z0-9._-]{3,20}$/.test(uname)) {
                  alert('Username must be 3-20 chars: letters, numbers, ., _, -');
                  return;
                }
                try {
                  const db = await getDb();
                  const existing = await db.collection('Users').where('username', '==', uname).limit(1).get();
                  if (!existing.empty) {
                    alert('Username already taken');
                    return;
                  }
                  const cred = await firebaseGlobal.auth().createUserWithEmailAndPassword(usernameToEmail(uname), pwd);
                  const ip = await fetchClientIp();
                  const now = window.firebase.firestore.FieldValue.serverTimestamp();
                  await db.collection('Users').doc(cred.user.uid).set({
                    username: uname,
                    ip: ip || '',
                    lastVisit: now,
                    canEdit: false,
                    createdAt: now,
                  }, { merge: true });
                  location.hash = '#home';
                } catch (e) {
                  alert('Sign-up failed: ' + (e && e.message ? e.message : String(e)));
                }
              });
            }

            const features = [
              'auth',
              'database',
              'firestore',
              'functions',
              'messaging',
              'storage',
              'analytics',
              'remoteConfig',
              'performance',
            ].filter(feature => app && typeof app[feature] === 'function');
            sdkStatus.textContent = 'Firebase SDK loaded: ' + features.join(', ');
          }
        } catch (e) {
          console.error(e);
          sdkStatus.textContent = window.__FIREBASE_CONFIG__
            ? 'Error initializing Firebase. See console.'
            : 'Missing /config/firebaseConfig.js. Add your Firebase config.';
        }

      // Logs: nothing to gate (read-only UI). Keep function as no-op.
      function refreshLogsVisibility() {}

        // Initialize Database Tree UI
        if (dbRefreshTree) {
          dbRefreshTree.addEventListener('click', () => buildDbTree());
        }
        buildDbTree();
        // Ensure visibility is correct on initial load too
        refreshImportVisibility();
      refreshLogsVisibility();

        // --- Permission helpers ---
        async function requireEditor() {
          const firebaseGlobal = window.firebase;
          if (!firebaseGlobal || !firebaseGlobal.auth) {
            alert('Firebase not initialized.');
            return false;
          }
          const user = firebaseGlobal.auth().currentUser;
          if (!user) {
            alert('You must be signed in to import. Go to the Sign In page first.');
            return false;
          }
          try {
            const db = await getDb();
            const doc = await db.collection('Users').doc(user.uid).get();
            const data = doc && doc.exists ? (doc.data() || {}) : {};
            const setAllowed = await isSetImportAllowed();
            if (data && data.canEdit === true && setAllowed) return true;
          } catch (_) {}
          if (!(await isSetImportAllowed())) {
            alert('Import disabled for this set (check CanImportCards/CanImportSealed on the set doc).');
            return false;
          }
          alert('You do not have permission to import. Ask an admin to set Users/' + (user.uid || '') + '.canEdit = true in Firestore.');
          return false;
        }

        // Import text into the currently selected set and view (Cards or Sealed)
        async function importTextForCurrentSelection(text) {
          function cleanNameForId(rawName) {
            let s = String(rawName || '').trim();
            if (!s) return '';
            // Remove any bracketed segments like [Reverse Holo], [Holo], etc.
            s = s.replace(/\s*\[[^\]]*\]\s*/g, ' ');
            // Remove any inline number fragments like " #123"
            s = s.replace(/\s*#\d+\s*/g, ' ');
            // Collapse extra whitespace
            s = s.replace(/\s{2,}/g, ' ').trim();
            return s;
          }
          const ok = await requireEditor();
          if (!ok) return;
          if (!dbState.setName) {
            alert('Select a set first.');
            return;
          }
          const db = await getDb();
          const firebaseGlobal = window.firebase;
          const collectionName = (dbState.view === 'Sealed') ? 'Sealed' : 'Cards';
          const setDocRef = db
            .collection('Pokemon Packs')
            .doc(dbState.language || 'English')
            .collection(dbState.category || 'Mega Evolution')
            .doc(dbState.setName);
          // Ensure parent doc exists
          try {
            const now = (firebaseGlobal && firebaseGlobal.firestore && firebaseGlobal.firestore.FieldValue && firebaseGlobal.firestore.FieldValue.serverTimestamp) ? firebaseGlobal.firestore.FieldValue.serverTimestamp() : null;
            await setDocRef.set({ createdAt: now || new Date() }, { merge: true });
          } catch (_) {}
          const raw = String(text || '').trim();
          let items = [];
          // Try JSON first
          if (raw.startsWith('[') || raw.startsWith('{')) {
            try {
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed)) {
                items = parsed;
              } else if (parsed && typeof parsed === 'object') {
                items = [parsed];
              }
            } catch (_) {
              // fall back to line-based
            }
          }
          // Fallback to CSV-ish lines: name,number,price,imageUrl
          if (items.length === 0) {
            const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(l => !!l);
            if (lines.length === 0) {
              alert('No data found.');
              return;
            }
            items = lines.map(line => {
              const parts = line.split(',');
              return {
                name: (parts[0] || '').trim(),
                number: (parts[1] || '').trim(),
                price: parseFloat((parts[2] || '').trim()),
                imageUrl: parts.slice(3).join(',').trim(),
                printing: ''
              };
            });
          }
          dbOutput.innerHTML = '<div class="card"><div class="small mono">Importing ' + items.length + ' ' + collectionName + '…</div></div>';
          const targetColRef = setDocRef.collection(collectionName);
          let batch = db.batch();
          let ops = 0;
          const commits = [];
          const maxOps = 450; // stay under 500 writes per batch
          for (const item of items) {
            const nameRaw = (item && (item.name || item.Name)) || '';
            const printingRaw = (item && (item.printing || item.Printing)) || '';
            const rarity = (item && (item.rarity || item.Rarity)) || '';
            const numberRaw = (item && (item.number || item.Number)) || '';
            const priceRaw = (item && (item.price || item.Price)) || '';
            const pictureUrl = (item && (item.imageUrl || item.ImageUrl || item.imageURL)) || '';
            const name = String(nameRaw).trim();
            // Parse number like "054/132" → 54
            let numberVal = 0;
            if (typeof numberRaw === 'number') numberVal = numberRaw;
            else if (typeof numberRaw === 'string') {
              const m = numberRaw.match(/^\s*(\d+)/);
              numberVal = m ? parseInt(m[1], 10) : 0;
            }
            // Derive display id: include printing for variants; accept any printing string as-is
            const normalizedPrinting = String(printingRaw || '').trim();
            // For cards, do NOT include numbers or bracketed printing in the document id
            // Keep fields like Number/Printing in the document data as usual
            const displayId = cleanNameForId(name);
            const costVal = typeof priceRaw === 'number' ? priceRaw : parseFloat(String(priceRaw || '').trim());
            if (!name) continue;
            const data = {
              'Name': displayId,
              'Number': Number.isFinite(numberVal) ? numberVal : 0,
              'Amount Owned': 0,
              'Cost': Number.isFinite(costVal) ? costVal : 0,
              'Location': 'N/A',
              'Picture Link': pictureUrl
            };
            if (rarity) data['Rarity'] = String(rarity);
            if (normalizedPrinting) data['Printing'] = String(normalizedPrinting);
            let docRef = null;
            if (collectionName === 'Cards') {
              // Use auto-generated document IDs to allow duplicate names
              docRef = targetColRef.doc();
            } else {
              // For Sealed, keep name-based IDs
              const safeId = makeSafeDocId(displayId || name);
              if (!safeId) continue;
              docRef = targetColRef.doc(safeId);
            }
            batch.set(docRef, data, { merge: true });
            ops++;
            if (ops >= maxOps) {
              commits.push(batch.commit());
              batch = db.batch();
              ops = 0;
            }
          }
          if (ops > 0) {
            commits.push(batch.commit());
          }
          try {
            await Promise.all(commits);
            dbOutput.innerHTML = '<div class="card"><div class="small mono">Imported ' + items.length + ' items to ' + (dbState.category || '') + ' / ' + dbState.setName + ' / ' + collectionName + '.</div></div>';
            await buildDbTree();
          } catch (e) {
            dbOutput.innerHTML = '<div class="card"><div class="small mono" style="color:#C53030;">Import failed: ' + (e && e.message ? e.message : String(e)) + '</div></div>';
          }
        }

        async function importBaseSetCards() {
          // Try fetching the default source file for the current set
          if (!dbState.setName) {
            alert('Select a set first.');
            return;
          }
          let text = '';
          try {
            const path = '.' + buildDataPathForCurrentSet();
            const res = await fetch(path, { cache: 'no-cache' });
            if (!res.ok) throw new Error('HTTP ' + res.status);
            text = await res.text();
          } catch (e) {
            alert('Failed to fetch source file for current set. If you opened the file directly, run a local server or use "Import From File".\n\nSource: ' + buildDataPathForCurrentSet() + '\nError: ' + (e && e.message ? e.message : String(e)));
            return;
          }
          await importCardsFromText(text);
        }

        const dbImportFileInput = document.getElementById('dbImportFile');
        const dbImportAllBtn = document.getElementById('dbImportAllBtn');
        const dbImportPhotosBtn = document.getElementById('dbImportPhotosBtn');
        const dbImportPricesBtn = document.getElementById('dbImportPricesBtn');
        // Keep last-read text if user switches actions
        let __lastImportFileText = '';
        async function readSelectedImportFileText() {
          const file = dbImportFileInput && dbImportFileInput.files && dbImportFileInput.files[0];
          if (!file) {
            if (__lastImportFileText) return __lastImportFileText;
            alert('Choose a file first.');
            throw new Error('No file selected');
          }
          const text = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(String(reader.result || ''));
            reader.onerror = () => reject(reader.error || new Error('File read error'));
            reader.readAsText(file);
          });
          __lastImportFileText = String(text || '');
          return __lastImportFileText;
        }
        if (dbImportFileInput) {
          dbImportFileInput.addEventListener('change', async () => {
            // Just cache the text; do not auto-import
            try { await readSelectedImportFileText(); } catch (_) {}
          });
        }
        // Small parser used by all import/update actions
        function __parseImportItems(rawText) {
          const raw = String(rawText || '').trim();
          let items = [];
          if (!raw) return items;
          if (raw.startsWith('[') || raw.startsWith('{')) {
            try {
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed)) items = parsed;
              else if (parsed && typeof parsed === 'object') items = [parsed];
            } catch (_) {}
          }
          if (items.length === 0) {
            const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(l => !!l);
            items = lines.map(line => {
              const parts = line.split(',');
              return {
                name: (parts[0] || '').trim(),
                number: (parts[1] || '').trim(),
                price: parseFloat((parts[2] || '').trim()),
                imageUrl: parts.slice(3).join(',').trim(),
                printing: ''
              };
            });
          }
          return items;
        }
        // Local helper to normalize sealed ids similar to import flow
        function __cleanNameForId(rawName) {
          let s = String(rawName || '').trim();
          if (!s) return '';
          s = s.replace(/\s*\[[^\]]*\]\s*/g, ' ');
          s = s.replace(/\s*#\d+\s*/g, ' ');
          s = s.replace(/\s{2,}/g, ' ').trim();
          return s;
        }
        async function updatePhotosFromText(text) {
          const ok = await requireEditor();
          if (!ok) return;
          if (!dbState.setName) { alert('Select a set first.'); return; }
          const db = await getDb();
          const collectionName = (dbState.view === 'Sealed') ? 'Sealed' : 'Cards';
          const setDocRef = db
            .collection('Pokemon Packs')
            .doc(dbState.language || 'English')
            .collection(dbState.category || 'Mega Evolution')
            .doc(dbState.setName);
          const items = __parseImportItems(text);
          if (items.length === 0) { alert('No data found.'); return; }
          dbOutput.innerHTML = '<div class="card"><div class="small mono">Updating photo links…</div></div>';
          let updated = 0;
          if (collectionName === 'Sealed') {
            let batch = db.batch();
            let ops = 0;
            const commits = [];
            for (const item of items) {
              const nameRaw = (item && (item.name || item.Name)) || '';
              const imageUrl = (item && (item.imageUrl || item.ImageUrl || item.imageURL)) || '';
              const safeId = __cleanNameForId(nameRaw || '');
              if (!safeId || !imageUrl) continue;
              const docRef = setDocRef.collection('Sealed').doc(safeId);
              batch.set(docRef, { 'Picture Link': String(imageUrl) }, { merge: true });
              updated++; ops++;
              if (ops >= 450) { commits.push(batch.commit()); batch = db.batch(); ops = 0; }
            }
            if (ops > 0) commits.push(batch.commit());
            try { await Promise.all(commits); } catch (_) {}
          } else {
            // Cards: match by Number and optional Printing
            const colRef = setDocRef.collection('Cards');
            const toNumber = (val) => {
              if (typeof val === 'number') return val;
              if (typeof val === 'string') {
                const m = val.match(/^\s*(\d+)/);
                return m ? parseInt(m[1], 10) : NaN;
              }
              return NaN;
            };
            for (const item of items) {
              const num = toNumber((item && (item.number || item.Number)) || '');
              const prt = normalizePrintingLabel((item && (item.printing || item.Printing)) || '');
              const imageUrl = (item && (item.imageUrl || item.ImageUrl || item.imageURL)) || '';
              if (!Number.isFinite(num) || !imageUrl) continue;
              try {
                const q = await colRef.where('Number', '==', num).get();
                if (q.empty) continue;
                let targetDoc = null;
                q.forEach(doc => {
                  if (targetDoc) return;
                  const d = doc.data() || {};
                  const dp = String(d['Printing'] || '').trim();
                  const dpNorm = normalizePrintingLabel(dp);
                  if (prt) {
                    if (dpNorm.toLowerCase() === prt.toLowerCase()) targetDoc = doc;
                  } else {
                    if (!dpNorm) targetDoc = doc;
                  }
                });
                if (!targetDoc) targetDoc = q.docs[0] || null;
                if (targetDoc) {
                  await targetDoc.ref.set({ 'Picture Link': String(imageUrl) }, { merge: true });
                  updated++;
                }
              } catch (_) {}
            }
          }
          dbOutput.innerHTML = '<div class="card"><div class="small mono">Updated photos for ' + updated + ' item(s).</div></div>';
          await loadCurrentView();
        }
        async function updatePricesFromText(text) {
          const ok = await requireEditor();
          if (!ok) return;
          if (!dbState.setName) { alert('Select a set first.'); return; }
          const db = await getDb();
          const collectionName = (dbState.view === 'Sealed') ? 'Sealed' : 'Cards';
          const setDocRef = db
            .collection('Pokemon Packs')
            .doc(dbState.language || 'English')
            .collection(dbState.category || 'Mega Evolution')
            .doc(dbState.setName);
          const items = __parseImportItems(text);
          if (items.length === 0) { alert('No data found.'); return; }
          dbOutput.innerHTML = '<div class="card"><div class="small mono">Updating prices…</div></div>';
          let updated = 0;
          if (collectionName === 'Sealed') {
            let batch = db.batch();
            let ops = 0;
            const commits = [];
            for (const item of items) {
              const nameRaw = (item && (item.name || item.Name)) || '';
              const priceRaw = (item && (item.price || item.Price)) || '';
              const costVal = typeof priceRaw === 'number' ? priceRaw : parseFloat(String(priceRaw || '').trim());
              const safeId = __cleanNameForId(nameRaw || '');
              if (!safeId || !Number.isFinite(costVal)) continue;
              const docRef = setDocRef.collection('Sealed').doc(safeId);
              batch.set(docRef, { 'Cost': Number(costVal) }, { merge: true });
              updated++; ops++;
              if (ops >= 450) { commits.push(batch.commit()); batch = db.batch(); ops = 0; }
            }
            if (ops > 0) commits.push(batch.commit());
            try { await Promise.all(commits); } catch (_) {}
          } else {
            // Cards: match by Number and optional Printing
            const colRef = setDocRef.collection('Cards');
            const toNumber = (val) => {
              if (typeof val === 'number') return val;
              if (typeof val === 'string') {
                const m = val.match(/^\s*(\d+)/);
                return m ? parseInt(m[1], 10) : NaN;
              }
              return NaN;
            };
            for (const item of items) {
              const num = toNumber((item && (item.number || item.Number)) || '');
              const prt = normalizePrintingLabel((item && (item.printing || item.Printing)) || '');
              const priceRaw = (item && (item.price || item.Price)) || '';
              const costVal = typeof priceRaw === 'number' ? priceRaw : parseFloat(String(priceRaw || '').trim());
              if (!Number.isFinite(num) || !Number.isFinite(costVal)) continue;
              try {
                const q = await colRef.where('Number', '==', num).get();
                if (q.empty) continue;
                let targetDoc = null;
                q.forEach(doc => {
                  if (targetDoc) return;
                  const d = doc.data() || {};
                  const dp = String(d['Printing'] || '').trim();
                  const dpNorm = normalizePrintingLabel(dp);
                  if (prt) {
                    if (dpNorm.toLowerCase() === prt.toLowerCase()) targetDoc = doc;
                  } else {
                    if (!dpNorm) targetDoc = doc;
                  }
                });
                if (!targetDoc) targetDoc = q.docs[0] || null;
                if (targetDoc) {
                  await targetDoc.ref.set({ 'Cost': Number(costVal) }, { merge: true });
                  updated++;
                }
              } catch (_) {}
            }
          }
          dbOutput.innerHTML = '<div class="card"><div class="small mono">Updated prices for ' + updated + ' item(s).</div></div>';
          await loadCurrentView();
        }
        if (dbImportAllBtn) {
          dbImportAllBtn.addEventListener('click', async () => {
            try {
              const text = await readSelectedImportFileText();
              await importTextForCurrentSelection(text);
            } catch (_) {}
          });
        }
        if (dbImportPhotosBtn) {
          dbImportPhotosBtn.addEventListener('click', async () => {
            try {
              const text = await readSelectedImportFileText();
              await updatePhotosFromText(text);
            } catch (_) {}
          });
        }
        if (dbImportPricesBtn) {
          dbImportPricesBtn.addEventListener('click', async () => {
            try {
              const text = await readSelectedImportFileText();
              await updatePricesFromText(text);
            } catch (_) {}
          });
        }

        bindNavClicks();
        initRouter();

        // --- Quick Edit Modal logic ---
        const quickEditModal = document.getElementById('quickEditModal');
        const quickEditRows = document.getElementById('quickEditRows');
        const quickEditApply = document.getElementById('quickEditApply');
        const quickEditCancel = document.getElementById('quickEditCancel');
        const quickEditClose = document.getElementById('quickEditClose');
        const quickEditContext = document.getElementById('quickEditContext');

        async function openQuickEdit() {
          if (!dbState.setName) {
            alert('Select a set first.');
            return;
          }
          const isSealed = dbState.view === 'Sealed';
          if (quickEditContext) quickEditContext.textContent = (dbState.category || '') + ' / ' + (dbState.setName || '') + ' / ' + (dbState.view || '');
          let html = '';
          if (isSealed) {
            html += '<div class="grid-quick sealed">';
            html += '<div class="hdr">Product</div><div class="hdr">Amount</div><div class="hdr">Location</div>';
            // Build product dropdown from current set's Sealed docs
            try {
              const db = await getDb();
              const colRef = db
                .collection('Pokemon Packs')
                .doc(dbState.language || 'English')
                .collection(dbState.category || 'Mega Evolution')
                .doc(dbState.setName)
                .collection('Sealed');
              const snap = await colRef.get();
              const options = [];
              options.push('<option value="">Select product…</option>');
              const names = [];
              snap.forEach(d => names.push(String(d.id || '')));
              names.sort((a, b) => a.localeCompare(b));
              names.forEach(n => options.push('<option value="' + n.replace(/"/g, '&quot;') + '">' + n.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</option>'));
              html += '<select id="qe-s-prod-0">' + options.join('') + '</select>';
            } catch (_) {
              html += '<select id="qe-s-prod-0"><option value="">Select product…</option></select>';
            }
            html += '<input type="number" step="1" id="qe-s-amt-0" placeholder="+/-" value="1">';
            html += '<input type="text" id="qe-s-loc-0" placeholder="optional">';
            html += '</div>';
          } else {
            html += '<div class="grid-quick cards">';
            html += '<div class="hdr">Number</div><div class="hdr">Printing</div><div class="hdr">Amount</div><div class="hdr">Location</div>';
            for (let i = 0; i < 10; i++) {
              html += '<input type="number" min="0" step="1" id="qe-num-' + i + '" placeholder="#">';
              html += '<select id="qe-prt-' + i + '">'
                + '<option value="">Normal</option>'
                + '<option value="Reverse Holofoil">Reverse Holofoil</option>'
                + '<option value="Holofoil">Holofoil</option>'
              + '</select>';
              html += '<input type="number" step="1" id="qe-amt-' + i + '" placeholder="+/-" value="1">';
              html += '<input type="text" id="qe-loc-' + i + '" placeholder="optional">';
            }
            html += '</div>';
          }
          quickEditRows.innerHTML = html;
          quickEditModal.classList.remove('hidden');
        }

        function closeQuickEdit() {
          if (quickEditModal) quickEditModal.classList.add('hidden');
        }

        function normalizePrintingLabel(s) {
          const raw = String(s || '').trim();
          if (!raw) return '';
          if (/^normal$/i.test(raw)) return '';
          return raw;
        }

        async function applyQuickEdits() {
          // Quick edit permission: only requires signed-in user with canEdit=true
          try {
            const firebaseGlobal = window.firebase;
            if (!firebaseGlobal || !firebaseGlobal.auth) {
              alert('Firebase not initialized.');
              return;
            }
            const user = firebaseGlobal.auth().currentUser;
            if (!user) {
              alert('You must be signed in to edit. Go to the Sign In page first.');
              return;
            }
            const dbCheck = await getDb();
            const doc = await dbCheck.collection('Users').doc(user.uid).get();
            const data = doc && doc.exists ? (doc.data() || {}) : {};
            if (!(data && data.canEdit === true)) {
              alert('You do not have permission to edit. Ask an admin to set Users/' + (user.uid || '') + '.canEdit = true in Firestore.');
              return;
            }
          } catch (_) {
            alert('Permission check failed.');
            return;
          }
          if (!dbState.setName) {
            alert('Select a set first.');
            return;
          }
          const db = await getDb();
          const firebaseGlobal = window.firebase;
          const setRef = db
            .collection('Pokemon Packs')
            .doc(dbState.language || 'English')
            .collection(dbState.category || 'Mega Evolution')
            .doc(dbState.setName);
          const isSealed = dbState.view === 'Sealed';
          const collection = isSealed ? 'Sealed' : 'Cards';
          const colRef = setRef.collection(collection);
          const updates = [];
          const logs = [];
          const nowServerTs = (firebaseGlobal && firebaseGlobal.firestore && firebaseGlobal.firestore.FieldValue && firebaseGlobal.firestore.FieldValue.serverTimestamp)
            ? firebaseGlobal.firestore.FieldValue.serverTimestamp()
            : new Date();
          if (isSealed) {
            const prodId = String((document.getElementById('qe-s-prod-0') || {}).value || '').trim();
            const amt = parseInt(String((document.getElementById('qe-s-amt-0') || {}).value || '').trim(), 10);
            const loc = String((document.getElementById('qe-s-loc-0') || {}).value || '').trim();
            if (prodId && Number.isFinite(amt) && amt !== 0) {
              try {
                const docRef = colRef.doc(prodId);
                const docSnap = await docRef.get();
                if (docSnap.exists) {
                  const data = {};
                  const cur = Number((docSnap.data() || {})['Amount Owned'] || 0);
                  const next = Math.max(0, cur + amt);
                  data['Amount Owned'] = next;
                  if (loc) data['Location'] = loc;
                  updates.push({ ref: docRef, data });
                  logs.push({
                    type: 'sealed',
                    time: nowServerTs,
                    sealedName: prodId,
                    amount: amt,
                    location: loc || ''
                  });
                }
              } catch (_) {}
            }
          } else {
            for (let i = 0; i < 10; i++) {
              const num = parseInt(String((document.getElementById('qe-num-' + i) || {}).value || '').trim(), 10);
              const prt = normalizePrintingLabel((document.getElementById('qe-prt-' + i) || {}).value || '');
              const amt = parseInt(String((document.getElementById('qe-amt-' + i) || {}).value || '').trim(), 10);
              const loc = String((document.getElementById('qe-loc-' + i) || {}).value || '').trim();
              if (!Number.isFinite(num) || !Number.isFinite(amt) || amt === 0) continue;
              try {
                const q = await colRef.where('Number', '==', num).get();
                if (q.empty) continue;
                let targetDoc = null;
                q.forEach(doc => {
                  if (targetDoc) return;
                  const d = doc.data() || {};
                  const dp = String(d['Printing'] || '').trim();
                  const dpNorm = normalizePrintingLabel(dp);
                  if (prt) {
                    if (dpNorm.toLowerCase() === prt.toLowerCase()) targetDoc = doc;
                  } else {
                    if (!dpNorm) targetDoc = doc;
                  }
                });
                if (!targetDoc) {
                  targetDoc = q.docs[0] || null;
                }
                if (targetDoc) {
                  const data = {};
                  const cur = Number((targetDoc.data() || {})['Amount Owned'] || 0);
                  const next = Math.max(0, cur + amt);
                  data['Amount Owned'] = next;
                  if (loc) data['Location'] = loc;
                  updates.push({ ref: targetDoc.ref, data });
                  logs.push({
                    type: 'card',
                    time: nowServerTs,
                    cardName: String(((targetDoc.data() || {})['Name']) || targetDoc.id || ''),
                    number: num,
                    print: prt || 'Normal',
                    amount: amt,
                    location: loc || '',
                    set: ((dbState && dbState.category) ? (dbState.category + ' / ') : '') + (dbState && dbState.setName ? dbState.setName : '')
                  });
                }
              } catch (_) {}
            }
          }
          if (updates.length === 0) {
            alert('No valid rows to update.');
            return;
          }
          let batch = db.batch();
          const commits = [];
          let ops = 0;
          const flush = () => { commits.push(batch.commit()); batch = db.batch(); ops = 0; };
          for (const u of updates) {
            batch.set(u.ref, u.data, { merge: true });
            ops++;
            if (ops >= 450) flush();
          }
          // Group logs by submission into a single document per type (up to 10 items entered via Quick Edit)
          const cardItems = logs.filter(l => l.type === 'card').map(l => ({
            cardName: l.cardName,
            number: l.number,
            print: l.print,
            amount: l.amount,
            location: l.location,
            set: l.set
          }));
          const sealedItems = logs.filter(l => l.type === 'sealed').map(l => ({
            sealedName: l.sealedName,
            amount: l.amount,
            location: l.location
          }));
          if (cardItems.length > 0) {
            const logRef = db.collection('CardLogs').doc();
            batch.set(logRef, { time: nowServerTs, items: cardItems }, { merge: false });
            ops++;
            if (ops >= 450) flush();
          }
          if (sealedItems.length > 0) {
            const logRef = db.collection('SealedLogs').doc();
            batch.set(logRef, { time: nowServerTs, items: sealedItems }, { merge: false });
            ops++;
            if (ops >= 450) flush();
          }
          if (ops > 0) commits.push(batch.commit());
          try {
            await Promise.all(commits);
            closeQuickEdit();
            await loadCurrentView();
          } catch (e) {
            alert('Update failed: ' + (e && e.message ? e.message : String(e)));
          }
        }

        if (dbQuickEditBtn) dbQuickEditBtn.addEventListener('click', openQuickEdit);
        if (quickEditApply) quickEditApply.addEventListener('click', () => applyQuickEdits());
        if (quickEditCancel) quickEditCancel.addEventListener('click', closeQuickEdit);
        if (quickEditClose) quickEditClose.addEventListener('click', closeQuickEdit);

        // --- Add Set Modal logic ---
        const addSetModal = document.getElementById('addSetModal');
        const addSetContext = document.getElementById('addSetContext');
        const addSetName = document.getElementById('addSetName');
        const addSetCategory = document.getElementById('addSetCategory');
        const addSetCards = document.getElementById('addSetCards');
        const addSetTotalCards = document.getElementById('addSetTotalCards');
        const addSetImage = document.getElementById('addSetImage');
        const addSetCanImportCards = document.getElementById('addSetCanImportCards');
        const addSetCanImportSealed = document.getElementById('addSetCanImportSealed');
        const addSetApply = document.getElementById('addSetApply');
        const addSetCancel = document.getElementById('addSetCancel');
        const addSetClose = document.getElementById('addSetClose');
        const addSetCategoryLabel = document.getElementById('addSetCategoryLabel');

        // Add Category modal elements
        const addCategoryModal = document.getElementById('addCategoryModal');
        const addCategoryContext = document.getElementById('addCategoryContext');
        const addCategoryName = document.getElementById('addCategoryName');
        const addCategoryApply = document.getElementById('addCategoryApply');
        const addCategoryCancel = document.getElementById('addCategoryCancel');
        const addCategoryClose = document.getElementById('addCategoryClose');

        function openAddSetModal() {
          if (!dbState.category || !dbState.language) {
            alert('Select a category first.');
          }
          if (addSetContext) addSetContext.textContent = (dbState.language || '') + ' / ' + (dbState.category || '(enter category)');
          const knowCategory = !!(dbState.category && dbState.category.trim());
          if (addSetCategoryLabel) addSetCategoryLabel.style.display = knowCategory ? 'none' : '';
          if (addSetCategory) {
            addSetCategory.style.display = knowCategory ? 'none' : '';
            addSetCategory.disabled = knowCategory;
            addSetCategory.value = knowCategory ? '' : (dbState.category || '');
          }
          if (addSetName) addSetName.value = '';
          if (addSetCards) addSetCards.value = '';
          if (addSetTotalCards) addSetTotalCards.value = '';
          if (addSetImage) addSetImage.value = '';
          if (addSetCanImportCards) addSetCanImportCards.checked = false;
          if (addSetCanImportSealed) addSetCanImportSealed.checked = false;
          addSetModal.classList.remove('hidden');
        }
        function closeAddSetModal() {
          if (addSetModal) addSetModal.classList.add('hidden');
        }
        if (addSetCancel) addSetCancel.addEventListener('click', closeAddSetModal);
        if (addSetClose) addSetClose.addEventListener('click', closeAddSetModal);
        if (addSetApply) addSetApply.addEventListener('click', async () => {
          // Permission: editor only
          try {
            const firebaseGlobal = window.firebase;
            if (!firebaseGlobal || !firebaseGlobal.auth) { alert('Firebase not initialized.'); return; }
            const user = firebaseGlobal.auth().currentUser;
            if (!user) { alert('Sign in to create a set.'); return; }
            const dbPerm = await getDb();
            const doc = await dbPerm.collection('Users').doc(user.uid).get();
            const data = doc && doc.exists ? (doc.data() || {}) : {};
            if (!(data && data.canEdit === true)) { alert('You do not have permission to create sets.'); return; }
          } catch (_) { alert('Permission check failed.'); return; }
          const categoryFromInput = String((addSetCategory && addSetCategory.value || '')).trim();
          const category = categoryFromInput || (dbState.category || '');
          const name = String((addSetName && addSetName.value || '')).trim();
          const cards = parseInt(String((addSetCards && addSetCards.value || '')).trim(), 10);
          const totalCards = parseInt(String((addSetTotalCards && addSetTotalCards.value || '')).trim(), 10);
          const image = String((addSetImage && addSetImage.value || '')).trim();
          const flagCards = !!(addSetCanImportCards && addSetCanImportCards.checked);
          const flagSealed = !!(addSetCanImportSealed && addSetCanImportSealed.checked);
          if (!category) { alert('Enter category name.'); return; }
          if (!name) { alert('Enter set name.'); return; }
          try {
            const db = await getDb();
            const ref = db.collection('Pokemon Packs').doc(dbState.language).collection(category).doc(name);
            await ref.set({
              'Cards': Number.isFinite(cards) ? cards : 0,
              'Total Cards': Number.isFinite(totalCards) ? totalCards : 0,
              'image': image || '',
              'CanImportCards': flagCards,
              'CanImportSealed': flagSealed,
              'createdAt': (window.firebase && window.firebase.firestore && window.firebase.firestore.FieldValue && window.firebase.firestore.FieldValue.serverTimestamp) ? window.firebase.firestore.FieldValue.serverTimestamp() : new Date()
            }, { merge: true });
            // Initialize empty subcollections so they appear in console
            try { await ref.collection('Cards').doc('_init').set({ placeholder: true }); } catch (_) {}
            try { await ref.collection('Sealed').doc('_init').set({ placeholder: true }); } catch (_) {}
            closeAddSetModal();
            await buildDbTree();
            await showCategoryOverview(dbState.language, category);
          } catch (e) {
            alert('Create failed: ' + (e && e.message ? e.message : String(e)));
          }
        });

        function openAddCategoryModal() {
          if (addCategoryContext) addCategoryContext.textContent = (dbState.language || 'English');
          if (addCategoryName) addCategoryName.value = '';
          if (addCategoryModal) addCategoryModal.classList.remove('hidden');
        }
        function closeAddCategoryModal() {
          if (addCategoryModal) addCategoryModal.classList.add('hidden');
        }
        if (addCategoryCancel) addCategoryCancel.addEventListener('click', closeAddCategoryModal);
        if (addCategoryClose) addCategoryClose.addEventListener('click', closeAddCategoryModal);
        if (addCategoryApply) addCategoryApply.addEventListener('click', async () => {
          // editor permission
          try {
            const firebaseGlobal = window.firebase;
            if (!firebaseGlobal || !firebaseGlobal.auth) { alert('Firebase not initialized.'); return; }
            const user = firebaseGlobal.auth().currentUser;
            if (!user) { alert('Sign in to create a category.'); return; }
            const dbPerm = await getDb();
            const doc = await dbPerm.collection('Users').doc(user.uid).get();
            const data = doc && doc.exists ? (doc.data() || {}) : {};
            if (!(data && data.canEdit === true)) { alert('You do not have permission to create categories.'); return; }
          } catch (_) { alert('Permission check failed.'); return; }
          const cat = String((addCategoryName && addCategoryName.value || '')).trim();
          if (!cat) { alert('Enter category name.'); return; }
          try {
            const db = await getDb();
            // Create hidden placeholder set to surface the category
            const ref = db.collection('Pokemon Packs').doc(dbState.language || 'English').collection(cat).doc('_placeholder');
            await ref.set({
              hidden: true,
              createdAt: (window.firebase && window.firebase.firestore && window.firebase.firestore.FieldValue && window.firebase.firestore.FieldValue.serverTimestamp) ? window.firebase.firestore.FieldValue.serverTimestamp() : new Date()
            }, { merge: true });
            try { await ref.collection('Cards').doc('_init').set({ placeholder: true }); } catch (_) {}
            // Log category creation
            // Category logging removed
            closeAddCategoryModal();
            await buildDbTree();
            await showCategoryOverview(dbState.language || 'English', cat);
          } catch (e) {
            alert('Create category failed: ' + (e && e.message ? e.message : String(e)));
          }
        });

        // --- Logs: functions and events ---
        function setActiveLogsTab(view) {
          logsView = view;
          if (logsTabCards) logsTabCards.classList.toggle('active', view === 'card');
          if (logsTabSealed) logsTabSealed.classList.toggle('active', view === 'sealed');
        }
        function formatTs(ts) {
          try {
            if (!ts) return '';
            if (typeof ts.toDate === 'function') return ts.toDate().toLocaleString();
            const d = new Date(ts);
            return Number.isNaN(d.getTime()) ? '' : d.toLocaleString();
          } catch (_) { return ''; }
        }
        async function renderLogs(view) {
          if (view) setActiveLogsTab(view);
          if (!logsList) return;
          logsList.innerHTML = '<div class="small muted mono">Loading logs…</div>';
          try {
            const db = await getDb();
            // Map view to collection
            const coll = logsView === 'sealed' ? 'SealedLogs' : 'CardLogs';
            const snap = await db.collection(coll).orderBy('time', 'desc').limit(200).get();
            const rows = [];
            snap.forEach(d => rows.push({ id: d.id, data: d.data() || {} }));
            let html = '';
            html += '<div style="overflow:auto;"><table class="table">';
            if (logsView === 'card') {
              html += '<thead><tr><th>Time</th><th>Card Name</th><th>Number</th><th>Print</th><th>Amount</th><th>Location</th><th>Set</th></tr></thead><tbody>';
            } else {
              html += '<thead><tr><th>Time</th><th>Sealed Product</th><th>Amount</th><th>Location</th></tr></thead><tbody>';
            }
            rows.forEach(r => {
              const d = r.data || {};
              const timeCell = '<td class="small mono">' + (formatTs(d.time) || '') + '</td>';
              if (logsView === 'card') {
                if (Array.isArray(d.items)) {
                  d.items.forEach(it => {
                    html += '<tr>';
                    html += timeCell;
                    html += '<td>' + (it.cardName || '') + '</td>';
                    html += '<td>' + (Number.isFinite(it.number) ? it.number : (it.number || '')) + '</td>';
                    html += '<td>' + (it.print || '') + '</td>';
                    html += '<td>' + (Number.isFinite(it.amount) ? it.amount : (it.amount || '')) + '</td>';
                    html += '<td>' + (it.location || '') + '</td>';
                    html += '<td>' + (it.set || '') + '</td>';
                    html += '</tr>';
                  });
                } else {
                  html += '<tr>';
                  html += timeCell;
                  html += '<td>' + (d.cardName || '') + '</td>';
                  html += '<td>' + (Number.isFinite(d.number) ? d.number : (d.number || '')) + '</td>';
                  html += '<td>' + (d.print || '') + '</td>';
                  html += '<td>' + (Number.isFinite(d.amount) ? d.amount : (d.amount || '')) + '</td>';
                  html += '<td>' + (d.location || '') + '</td>';
                  html += '<td>' + (d.set || '') + '</td>';
                  html += '</tr>';
                }
              } else {
                if (Array.isArray(d.items)) {
                  d.items.forEach(it => {
                    html += '<tr>';
                    html += timeCell;
                    html += '<td>' + (it.sealedName || '') + '</td>';
                    html += '<td>' + (Number.isFinite(it.amount) ? it.amount : (it.amount || '')) + '</td>';
                    html += '<td>' + (it.location || '') + '</td>';
                    html += '</tr>';
                  });
                } else {
                  html += '<tr>';
                  html += timeCell;
                  html += '<td>' + (d.sealedName || '') + '</td>';
                  html += '<td>' + (Number.isFinite(d.amount) ? d.amount : (d.amount || '')) + '</td>';
                  html += '<td>' + (d.location || '') + '</td>';
                  html += '</tr>';
                }
              }
            });
            html += '</tbody></table></div>';
            if (rows.length === 0) {
              html = '<div class="small muted">No logs yet.</div>';
            }
            logsList.innerHTML = html;
            if (logsCount) logsCount.textContent = String(rows.length);
            if (!logsInitializedOnce) logsInitializedOnce = true;
          } catch (e) {
            logsList.innerHTML = '<div class="small mono" style="color:#C53030;">Failed to load logs: ' + (e && e.message ? e.message : String(e)) + '</div>';
          }
        }
        if (logsRefreshBtn) logsRefreshBtn.addEventListener('click', () => renderLogs());
        if (logsTabCards) logsTabCards.addEventListener('click', () => { setActiveLogsTab('card'); renderLogs(); });
        if (logsTabSealed) logsTabSealed.addEventListener('click', () => { setActiveLogsTab('sealed'); renderLogs(); });
        // Preload logs if the Logs page is active on load (default to Cards)
        if (location.hash === '#logs') renderLogs('card');

      });
    </script>
  </body>
</html>
